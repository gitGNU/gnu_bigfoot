% \title{The \texttt{bigfoot} package}
% \author{David Kastrup}
% \maketitle
% Purpose of this package is to provide a one-stop solution to almost
% all problems related to footnotes.  You can use it as a drop-in
% replacement of the \texttt{manyfoot} package, but without many of
% its shortcomings, and quite a few features of its own.  It uses the
% existing document class layouts for footnotes, so you can usually
% use it without having to worry about the looks.
%
% Features are:
% \begin{itemize}
% \item You can specify and use multiple footnote apparatus.
%   Footnotes for an apparatus lower on the
%   page\footnoteB{like this one} can be anchored in an
%   apparatus\footnote{The plural of ``apparatus'' is actually
%     ``apparatus''\footnoteB{Well, actually ``apparat\=us'' with a
%       long ``u'', but that's just obvious in spoken Latin.'}}
%   that is higher on the page.
% \item The last footnote in each apparatus may be broken to the next
%   page\footnote{This will probably be interesting for footnotes
%     that contain stuff like math equations\footnoteB+{Like
%       \begin{equation}
%         \label{eq:1}
%         \sum_{k=1}^\infty \frac{1}{k^2} = \frac{\pi^2}{6}
%       \end{equation}} or lists\footnoteB+{Like
%       \begin{itemize}
%       \item This, or
%       \item this.
%       \end{itemize}}.}
%   Any subordinate footnote anchors that get moved to the next page
%   will take the corresponding footnote with them.
% \item The order of footnotes in an apparatus is `natural': it starts
%   with any footnote that may have been broken from the next page,
%   followed by footnotes from the current page in the order of the
%   appearance of their footnote marks.\footnoteB{This footnote
%     appears above notes on notes.}
% \item Footnotes can be formatted in separate paragraphs, or be run
%   into a single paragraph.  The choice is made per footnote
%   apparatus, but can be overridden for single
%   footnotes.\footnote{Footnotes containing material like display
%     math\footnoteB{We had this already, right?} or list
%     environments\footnoteB{And this looks familiar, too.} have to be
%     done in vertical mode.}
% \item If footnotes are run into one paragraph, a variety of criteria
%   makes sure that this formatting is only chosen when it saves
%   noticeable space and delivers visually attractive results.
% \item Parameters for footnote formatting can be specified globally,
%   or separately for each footnote.
% \item The material in footnotes can contain |\verb|-like material
%   without problems.\footnote{We wrote \verb+|\verb|-like+ above in
%     the main text.\footnoteB{Well, this is not so impressive.  But we
%       wrote \verb/\verb+|\verb|-like+/ in the footnote then.}}
% \item You can use color in footnotes.  If a footnote gets broken
%   across pages, the color at the point of the break will get resumed
%   on the next page.
% \end{itemize}
% As an example of how simple the usage can be, here is the
% documentation driver for this document:
%    \begin{macrocode}
%<driver> \documentclass{ltxdoc}
%<driver> \usepackage{bigfoot}
%<driver> \usepackage{hyperref}
%    \end{macrocode}
% After loading the packages, we declare two footnote blocks.  One is
% the default footnote block, another block is called |subblock| and
% is numbered with letters.  The letters start new on each page.  Both
% footnote blocks default to in-paragraph footnotes.
%    \begin{macrocode}
%<driver> \DeclareNewFootnote[para]{default}
%<driver> \DeclareNewFootnote[para]{B}[alph]
%<driver> \MakeSortedPerPage{footnoteB}
%    \end{macrocode}
% In addition, we add an alternate footnote sequence that can be
% interspersed with the normal footnotes by use of the
% \cmd{\footnote'} command which we effectively define here.
%    \begin{macrocode}
%<driver> \newcounter{footalt}
%<driver> \def\thefootalt{\fnsymbol{footalt}}
%<driver> \MakeSortedPerPage[2]{footalt}
%<driver> \WithSuffix\def\footnotedefault'{\refstepcounter{footalt}%
%<driver>   \Footnotedefault{\thefootalt}}
%    \end{macrocode}
% Actually, that already was all.  We can now start the document.
%    \begin{macrocode}
%<driver> \begin{document}
%<driver> \DocInput{bigfoot.dtx}
%<driver> \end{document}
%    \end{macrocode}
% \StopEventually{}
% \section{The implementation}
% \subsection{Startup code}
% We declare the package and several compatibility options supposed to
% make |bigfoot| a drop-in replacement for |manyfoot|.
%    \begin{macrocode}
%<*style>
\NeedsTeXFormat{LaTeX2e}
\def\FN@next $#1: #2 #3${#2}
\ProvidesPackage{bigfoot}[\FN@next $Date: 2004/11/12 22:36:46 $
  Version \FN@next $Revision: 1.2 $]%}

\DeclareOption{para}{\PackageInfo{bigfoot}{Compatibility option `para'
  has no effect:^^J%
  Spacing will be guessed from `\string\@makefntext' unless^^J%
  `\string\@preparefnhtext' is redefined}}

\DeclareOption{para*}{\PackageInfo{bigfoot}{Compatibility option
    `para*':^^J%
    Redefining `\string\@preparefnhtext'}%
  \def\@preparefnhtext{\ifx\@thefnmark\@empty
    \else\@makefnmark\nobreak\fi}}

\DeclareOption{ruled}{\PassOptionsToPackage{ruled}{manyfoot}}
%    \end{macrocode}
% The |verbose| option talks about changed labels at the end of a
% run.  It is for debugging instable configurations that fail to
% converge after a number of \TeX\ runs.  The output is probably
% obscure.
%    \begin{macrocode}
\DeclareOption{verbose}{\AtBeginDocument{%
    \def\@testdef #1#2#3{%
      \def\reserved@a{#3}%
      \expandafter \ifx \csname #1@#2\endcsname
        \reserved@a
      \else \@tempswatrue
        \typeout{Changed label #1/#2:
          \csname #1@#2\endcsname->#3}%
      \fi}}}
%    \end{macrocode}
% The |trace| option is only available if you used |docstrip| while
% explicitly requesting |trace| functionality.
%    \begin{macrocode}
%<trace>\newif\iffoottrace
%<trace>\DeclareOption{trace}{%
%<trace>  \foottracetrue
%<trace>  \errorcontextlines\maxdimen
%<trace>  \showboxdepth3
%<trace>  \showboxbreadth100
%<trace>  \AtEndOfPackage{\RequirePackage{trace}\relax}%
%<trace>}

\ProcessOptions \relax
%    \end{macrocode}
% |hyperref|'s footnote support will just cause trouble.  So if
% |hyperref| was already loaded or is going to be loaded, we turn off
% its footnote support.  If you think you know what you are doing, you
% can use \cmd{\hypersetup} to turn it on again before the start of
% the document.
%    \begin{macrocode}
\ifx\hypersetup\@undefined
  \PassOptionsToPackage{hyperfootnotes=false}{hyperref}
\else
  \hypersetup{hyperfootnotes=false}
\fi
%    \end{macrocode}
% We require the |etex| package because
% \begin{enumerate}
% \item We need the facilities of the \eTeX\ engine; and where they
%   are not available, the error messages from not finding the |etex|
%   package or from loading it into the wrong engine make much more
%   sense than what would happen otherwise.
% \item We allocate quite a few registers, and the danger of running
%   out of them is smaller when the extra registers of \eTeX\ are
%   taken into account.
% \end{enumerate}
% We need the |manyfoot| package to build on.  The |suffix| and
% |perpage| package are needed for some small stuff.
%    \begin{macrocode}
\RequirePackage{etex}
\RequirePackage{manyfoot}
\RequirePackage{suffix}
\RequirePackage{perpage}
%    \end{macrocode}
% \subsection{Fixes to the \texttt{manyfoot} package}
% While those fixes have been submitted once to the author of
% |manyfoot|, they have not made it into its distribution at the
% current point of time.  In the interest of stability, it would
% probably be best just to incorporate the parts from |manyfoot| that
% get used by |bigfoot|.  Whatever.
%
% \begin{macro}{\MFL@reinsout}
%   We need the appropriate splitting parameters set for the footnote
%   again.  \cmd{\MFL@realinsert} does that, but it has the disadvantage
%   that it uses \cmd{\strutbox}, and that may be set to arbitrary
%   values at the time the output routine is invoked.  |manyfoot|
%   already has this problem with minipages: the split sizes will be
%   those of the font at the end of the minipage instead of those at the
%   time the footnote body was set up.  So we do this here, and see
%   later for more info about how to do this right:
%    \begin{macrocode}
\def\MFL@reinsout#1#2{\ifvoid#2\else
    \ifnum\count\@currbox>\z@
      \advance\@pageht \ht#2%
      \advance\@pageht \skip#2%
      \advance\@pageht \dp#2%
    \fi
    \MFL@realinsert{#2}{\unvbox#2}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\MFL@reins}
%   Actually, I don't get the purpose of the following line in the
%   first place.  But if we do need it for some reason, it is rather
%   certain that we don't want this empty insert to float.  Use
%   \cmd{\MFL@realinsert}, or set the floatingpenalty the hard way.
%    \begin{macrocode}
\def\MFL@reins#1#2{\ifvoid#2\else\insert#2{\floatingpenalty\@MM}\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\MFL@mpinsert}
% \begin{macro}{\MFL@minipage}
%   The structure of the \cmd{\MFL@mpinsert} box is overly
%   complicated, and it is a bad idea to unpack the boxes put into it
%   too early: the \cmd{\lastbox} command is pretty inefficient when
%   the list before it is long due to unpacking.  So we just leave
%   everything packed in its own boxes, and unpack only at the moment
%   when we are reinserting.
%    \begin{macrocode}
\long\def\MFL@mpinsert#1#2{%
  \global\setbox#1\vbox{%
    \unvbox#1%
    \nointerlineskip
    \vbox{#2}%
  }%
}

\def\MFL@minipage{%
  \ifinner\else
    \let\MFL@mpinsertsave\MFL@insert
    \MFL@reinsert \let\MFL@insert\MFL@mpinsert
  \fi
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\MFL@mpreinsert}
%   When reinserting, we put all but the last insertion into one
%   humongous blob.  This is so that the last insertion can be split
%   by \TeX's paragraph splitting routines.  The footnote types that
%   |bigfoot| supports will never get split by \TeX, anyhow, but it is
%   conceivable that other extension packages for manyfoot work
%   differently.  There is one difference, though: we let a slave mark
%   escape into the main vertical list.
%    \begin{macrocode}
\def\MFL@mpreinsert#1#2{%
  \ifvoid#2\else
    \setbox\@tempboxa\vbox\bgroup\unvbox#2%
      \global\setbox#2\lastbox
      \setbox\z@\lastbox
      \ifvoid\z@
        \egroup
        \setbox\z@\box#2%
      \else
        \MFL@removevboxes \unvbox\z@
        \egroup
        \setbox\z@\box#2%
        \MFL@mpinsertsave#2{\unvbox\@tempboxa}%
      \fi
    \ifvoid\z@\else
      \MFL@mpinsertsave#2{\unvbox\z@}%
    \fi
    \marks\FN@slave{\number\FN@id}%
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\MFL@removevboxes}
% The trick is like with \cmd{\removehboxes}.
%    \begin{macrocode}
\def\MFL@removevboxes{{\setbox\z@\lastbox
    \ifvbox\z@ \MFL@removevboxes \unvbox\z@\fi}}
%    \end{macrocode}
% \end{macro}
% While the above operations actually were fixes to |manyfoot|, now we
% actually patch it for our own purposes.  When allocating a new
% footnote, we set its maximum dimension to \cmd{\maxdimen} (since no
% hard limit makes sense, given that we recalculate all respective
% sizes at output time) and allocate a cache box to go with it.  We
% also add the insertion to the list of insertions in
% \cmd{\FN@nestlist}.
% \begin{macro}{\MFL@startplain}
% \begin{macro}{\MFL@startpara}
%    \begin{macrocode}
\def\MFL@startplain#1{\global\dimen#1\maxdimen
  \@cons\FN@nestlist{{}#1}%
  \expandafter\expandafter\expandafter\newbox\FN@cache#1}

\let\MFL@startpara\MFL@startplain
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\RestyleFootnote}
%   This macro gets two arguments: a footnote \meta{type}, and the
%   style to be used for it.  It works by redefining the corresponding
%   |Footnotetext|\meta{type} macro.
%    \begin{macrocode}
\def\RestyleFootnote#1#2{\expandafter\xdef
  \csname Footnotetext#1\endcsname{\expandafter
    \noexpand\csname MFL@fnote#2\endcsname{\csname footins#1\endcsname}}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FN@stripfootins}
% \begin{macro}{\FN@restylefootnote}
%   We need the same kind of functionality for a footnote specified by
%   its footnote insertion.  So we strip the footnote \meta{type} from
%   the insertion macro name.  Kind of ugly.
%    \begin{macrocode}
\expandafter\def\expandafter\FN@stripfootins\string\footins{}

\def\FN@restylefootnote#1#2{{\edef\next{%
      \noexpand\RestyleFootnote{\expandafter\FN@stripfootins
        \string#1}{#2}}\next}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Dealing with footnote-specific code}
% The formatting of footnotes is determined by macros such as
% \cmd{\@makefntext}.  For several blocks of footnotes, we might want
% to have several different ways for formatting them.  Whenever this
% is the case, we call them with
% \begin{quote}
%   |\FN@specific|\marg{insert\#}\marg{macroname}
% \end{quote}
% This will use the default \meta{macroname} unless a special macro has
% been defined with something like
% \begin{quote}
%   |\FootnoteSpecific\marg{type}|\def|\meta{macroname}\dots
% \end{quote}
% A number of other defining commands and constructs are available:
% those are pretty much like the ones for the \cmd{\WithSuffix} command
% implemented by the |suffix| package.
% \begin{macro}{\FN@specific}
%   We use |\romannumeral| here just for the purpose of sustaining
%   expansion.  It expands to nothing when followed by |\z@|
%   eventually.  Thus expanding the expansion of \cmd{\FN@specific}
%   again delivers the (unexpanded) final token to use.
%    \begin{macrocode}
\def\FN@specific#1#2{\romannumeral
  \ifcsname FN\string#2\number#1\endcsname
  \expandafter
    \z@\csname FN\string#2\number#1\expandafter\endcsname
  \else\expandafter\z@
    \expandafter#2\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FootnoteSpecific}
% \begin{macro}{\FN@specific@ii}
%   This is all a bit muddy, but quite similar to what the |suffix|
%   package does, so you might want to look there for the explanation.
%    \begin{macrocode}
\def\FootnoteSpecific#1{\count@\csname footins#1\endcsname\toks@{}%
  \FN@specific@ii}

\long\def\FN@specific@ii#1#2{\toks@\expandafter{\the\toks@#1}%
  \the\expandafter\toks@
  \csname FN\string#2\number\count@\endcsname}

\WithSuffix\def\FN@specific@ii\long{\toks@\expandafter
  {\the\toks@\long}\FN@specific@ii}

\WithSuffix\def\FN@specific@ii\global{\toks@\expandafter
  {\the\toks@\global}\FN@specific@ii}

\WithSuffix\def\FN@specific@ii\expandafter{\expandafter
  \FN@specific@ii\expandafter}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Putting footnotes into insertions}
% \subsubsection{Dealing with Ids}
%   Since we have to store additional information for each footnote as
%   long as it is not yet typeset, we allocate and deallocate numeric
%   `id's on an as-needed base, since we do not want to store this
%   sort of information indefinitely, with a large toll on hash space.
%   So we work with indirect ids, where the unique ids are just
%   referenced indirectly.  We do this with `slots'.
% \begin{macro}{\FN@slotxdef}
% \begin{macro}{\FN@slotget}
%   New slots are assigned values with \cmd{\FN@slotxdef}, which can
%   be retrieved again with \cmd{\FN@slotget}.
%    \begin{macrocode}
\def\FN@slotxdef#1{%
  \global\expandafter\xdef\csname FN@slot#1\endcsname}

\def\FN@slotget#1{\csname FN@slot#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\FN@slotfreelist}
% \begin{macro}{\FN@nextslot}
%   \cmd{\FN@slotfreelist} point to the first already allocated
%   available id to be reused.  If it is empty, none exist.  In that
%   case, \cmd{FN@nextslot} contains the next slot number to use.
%    \begin{macrocode}
\def\FN@slotfreelist{}
\def\FN@nextslot{1}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\FN@newslot}
%   This allocates a new slot by setting the given macro to a
%   currently unused slot number in decimal form.  If there is
%   something left in the freelist, it is assigned, otherwise a new
%   slot gets allocated.
%    \begin{macrocode}
\def\FN@newslot#1{%
  \ifx\FN@slotfreelist\@empty
    \edef#1{\FN@nextslot}%
    \xdef\FN@nextslot{\number\numexpr \FN@nextslot+\@ne}%
  \else
    \let#1\FN@slotfreelist
    \xdef\FN@slotfreelist{\csname FN@slot\FN@slotfreelist\endcsname}%
  \fi
%<trace>  \iffoottrace\message{^^JAllocated #1^^J}\fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FN@freeslot}
%   This frees a given slot (by number) again by adding it to the
%   freelist.
%    \begin{macrocode}
\def\FN@freeslot#1{%
%<trace>  \iffoottrace\message{^^JFreeing #1^^J}\fi
  \global\expandafter\let\csname FN@slot#1\endcsname=\FN@slotfreelist
  \xdef\FN@slotfreelist{#1}}
%    \end{macrocode}
% \end{macro}



% \subsubsection{Dealing with footnote stacks}
%    \begin{macrocode}
\global\let\FN@stacklist\@empty

\def\DefineFootnoteStack#1{%
  \global\expandafter\let\csname FN@stack@#1\endcsname\@empty
  \@cons\FN@stacklist{{#1}}%
}

\AtEndDocument{\FN@checkstacklist}

\def\FN@checkstacklist{{\let\@elt\FN@checkstack
  \FN@stacklist}}

\def\FN@checkstack#1{{\let\@elt\FN@checkstackentry
    \csname FN@stack#1@\endcsname}}

\def\FN@checkstackentry#1#2#3{%
  \PackageError{bigfoot}{Unfinished #1 #2 from line #3}%
  {The specified footnote range is uncomplete}}

\def\PushFootnoteMark#1{{\let\@elt\relax
  \expandafter\unrestored@protected@xdef \csname FN@stack@#1\endcsname
  {\@elt{#1}{\@thefnmark}{\number\inputlineno}\csname
  FN@stack@#1\endcsname}}}

\def\PopFootnoteMark#1{\expandafter
  \ifx\csname FN@stack@#1\endcsname\@empty
    \PackageError{bigfoot}{Empty footnote stack #1}%
    {The specified footnote type has no uncompleted range}%
  \else
  {\let\@elt\FN@firstpop
    \iffalse{\fi\csname FN@stack@#1\endcsname}}\fi}

\def\FN@firstpop#1#2#3{\protected@xdef\@thefnmark{#2}%
  \let\@elt\relax
  \expandafter\protected@xdef\csname FN@stack@#1\endcsname{%
    \iffalse}\fi}
%    \end{macrocode}

% \begin{macro}{\FN@cache}
%   Cacheboxes cache the typeset forms of the insertion boxes for a
%   certain configuration of footnotes.
%    \begin{macrocode}
\def\FN@cache#1{\csname FN@cache\number#1\endcsname}
%    \end{macrocode}
% \end{macro}

% \cmd{\FN@sortlist} takes the current vertical list and sorts the
% contained boxes according to their width (which is supposed to
% contain the sort key).
%
% The algorithm is a pretty straightforward insertion sort with
% $O(n^2)$~steps.  This is the best one can hope for without
% comparisons across non-adjacent list elements.  For presorted lists,
% the performance will be $O(n)$, and that's what we expect to see for
% simple cases (and when there are no sortkeys yet).  Any negative
% width will certainly hang the algorithm.
%
% It also happens that \TeX\ has a hardwired limit for grouping levels
% that hits at 255.  Oops.  We better not have a few hundred footnotes
% in a single block on one page\dots
%    \begin{macrocode}
\def\FN@sortlist{{%
  \setbox\z@\lastbox
  \ifvoid\z@ \else \FN@sortlist\FN@sortlistii \fi}}

\def\FN@sortlistii{%
  \setbox\tw@\lastbox
  \ifvoid\tw@\else
  \ifdim\wd\tw@<\wd\z@ {\FN@sortlistii}%
  \fi\nointerlineskip\box\tw@\fi\nointerlineskip\box\z@}
%    \end{macrocode}
% \begin{macro}{\FN@sortinsert}
%   This function is an \cmd{\@elt} function that will sort the given
%   insertion if it is non-empty and if there is no cache box present
%   (which would imply that the insertion had already been sorted
%   previously).
%    \begin{macrocode}
\def\FN@sortinsert#1#2{\ifvoid\FN@cache#2%
  \ifvoid#2\else\global\setbox#2\vbox{\unvbox#2%
    \FN@sortlist}\fi\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FN@maybeinvalidatecache}
%   This is called after pulling in additional material from the
%   page.  If the material added an insertion, the cache is junk and
%   must be regenerated.
%    \begin{macrocode}
\def\FN@maybeinvalidatecache#1#2{%
  \ifvoid#2\else\global\setbox\FN@cache#2=\box\voidb@x\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FN@regeneratecache}
%   This unconditionally regenerates one cache box.
%    \begin{macrocode}
\def\FN@regeneratecache#1#2{%
   \global\setbox\FN@cache#2=%
   \ifvoid#2%
     \box\voidb@x
   \else
     \vbox{\unvcopy#2%
       \setbox\z@\lastbox
       \def\FN@masterinsert{#2}%
       \FN@assembleboxes
       \nointerlineskip \box\z@}%
    \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FN@mayberegeneratecache}
%   This regenerates the cache in case the cache box has been voided
%   in order to mark it as invalid.
%    \begin{macrocode}
\def\FN@mayberegeneratecache#1#2{%
  \ifvoid\FN@cache#2%
    \FN@regeneratecache{}#2%
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FN@cachesize}
%   This calculates the size impact of a cache box on the current page
%   as a term to be added into a \cmd{\glueexpr}-type of expression.
%    \begin{macrocode}
\def\FN@cachesize#1#2{%
  \ifvoid\FN@cache#2%
  \else
    +\skip#2+(\ht\FN@cache#2+\dp\FN@cache#2)*\count#2/\@m
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FN@clearcache}
%   This just completely voids a cache register.
%    \begin{macrocode}
\def\FN@clearcache#1#2{%
  \global\setbox\FN@cache#2=\box\voidb@x}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macrocode}
\def\@makefnvtext#1{%
  \FN@specific\FN@masterinsert\@makefntext{%
    \vadjust{\nobreak\vskip-\baselineskip}\nobreak\hfill\break#1}}

\ifx\@preparefnhtext\@undefined
\def\@preparefnhtext{{%
  \setbox\z@\hbox{\FN@specific\FN@masterinsert\@makefntext{%
      \unskip\unpenalty\setbox\z@\lastbox
      \dimen@
        \ifnum\parshape>\z@
          \dimexpr\parshapeindent\tw@-\parshapeindent\@ne\relax
        \else \ifnum\hangafter=\@ne\hangindent \else
          \ifnum\hangafter=\m@ne -\hangindent
          \else \z@ \fi\fi\fi
      \dimen@ii\dimen@
      \ifhbox\z@ \advance\dimen@-\wd\z@
        \setbox\z@\hbox{\unhbox\z@}%
        \advance\dimen@\wd\z@
      \fi
      \xdef\FN@tempinfo{\hskip\the\dimen@
        \vadjust{}\nobreak\hskip-\the\dimen@ii\relax}}}}%
  \FN@tempinfo}
\fi
%    \end{macrocode}
% Now we have in |\FN@tempinfo| the excess width of the label we
% don't want to preserve when doing in-paragraph footnote setting.  A
% sequence of glue before a label now has to consist of stuff that
% vanishes at a breakpoint, followed by stuff that remains.
% We have to have two behaviors for the contents: behavior one is
% justification at the start of a line, behavior two is justification
% in the line.  When we are at the start of the line, preceding
% interword space disappears swallowed and so the natural criterion
% for distinguishing those cases is this initial line break.  This
% means that we can't avoid articifially adding a line break at the
% start of such a box.  We will back up its height again.  Some
% packages specify a |\hangindent| (I~know of no examples where they
% would actually set |\hangafter| to a value different from its
% default of~1, or set |\hangindent| to e negative value which would
% affect the right margin):  due to our artifical line at
% the top, the indent will actually be active for the first line
% already.  We back it out of the actual labels happening at the
% start of the line.  Two-line parshapes have the same effect: the
% first line is not actually used, and we put the relevant info for
% the first line into the label.  Different right indentation for the
% first line is something we can't simulate, but again, it should
% occur rarely.  When |\parshape| is active, |\hangindent| is ignored.
%    \begin{macrocode}

\ifx\@makefnvbox\@undefined
\def\@makefnvbox#1{\vbox{%
      \reset@font\footnotesize
      \interlinepenalty\interfootnotelinepenalty
      \hsize\MFL@columnwidth \@parboxrestore
      \noindent
      \rule\z@\footnotesep
      \advance\linepenalty500
      \let\@thefnmark\@empty
      \FN@specific\FN@masterinsert\@makefnvtext{#1}%
      \unskip\@finalstrut\strutbox
    }}
\fi

\def\hfootfraction{0.9}
\def\vtypefraction{0.6}

%    \end{macrocode}
% \begin{macro}{\FN@assembleboxes}
%   This will produce the finished product, by generating all boxes
%   (not yet unpacked in order not to make the |\lastbox| operation
%   inefficient as long as we may need it).  It is assumed that you
%   have already set |\box\z@| to |\lastbox| before calling this
%   routine (or, more likely, have already assembled and split the
%   last box).  The last, not yet unpacked |\vbox| is left in
%   |\box\z@| on return.  You have to take note of the depth of the
%   originally last box before calling this routine, as the depth will
%   not be reconstructed for the last box.
%
%   The last box might have come about by joining several horizontal
%   boxes, so splitting it might separate footnotes.  We deal with
%   that problem at a different point of time by checking the
%   respective Ids when breaking a vbox into pieces: if the split
%   piece does not contain the last footnote beginning, we switch to a
%   slow motion decomposal.
%    \begin{macrocode}
\def\FN@assembleboxes{%
  \ifhbox\z@
    \dimen@\dp\z@
    \dimen@ii\z@
    \setbox\tw@\box\voidb@x
    \loop \advance\dimen@ii\dimexpr\ht\z@+\dp\z@\relax
      \setbox\tw@\hbox{\box\z@\unhbox\tw@}%
      \setbox\z@\lastbox
    \ifhbox\z@
    \repeat
    {\FN@assembleboxes\nointerlineskip\box\z@}%
    \global\setbox\FN@tempbox\copy\tw@
    \setbox\z@\@makefnvbox{%
      \global\setbox\FN@tempbox
      \hbox{\unhbox\FN@tempbox\setbox\z@\lastbox\FN@removehboxes}%
      \unhbox\FN@tempbox}%
    \ifdim\FN@vfound>\dimexpr\vtypefraction\p@*\FN@found\relax
      \ifdim\dimexpr \ht\z@+\dp\z@>\hfootfraction\dimen@ii
        \global\setbox\FN@tempbox\box\tw@
        \setbox\z@\@makefnvbox{%
          \global\setbox\FN@tempbox
          \hbox{\let\@makefnbreak\break
            \unhbox\FN@tempbox\setbox\z@\lastbox\FN@removehboxes}%
          \unhbox\FN@tempbox}%
      \fi
    \fi
    \setbox\tw@\box\voidb@x
    \ht\z@\dimexpr \ht\z@+\dp\z@-\dimen@\relax
    \dp\z@\dimen@
  \else
    \ifvbox\z@{%
      \setbox\z@\lastbox
      \FN@assembleboxes\nointerlineskip\box\z@}%
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
% Ok, so here is the magic glue calculator.  |#1| and~|#2| give the
% range over which the preceding line changes from `short' to `long'.
% |#3| and |#4| give the range over which the current line changes
% from `short' to `long'.  Both are combined with a probabilistic or
% function, and then a penalty is chosen which ranges from |#5|
% to~|#6| for short to long.
%    \begin{macrocode}
\def\FN@fuzzyeval#1#2#3{%
  \ifdim\dimexpr#3<\dimexpr(#2)\relax
    \ifdim\dimexpr#3>\dimexpr(#1)\relax
      *(\dimexpr(#3)-(#1))%
      /(\dimexpr(#2)-(#1))%
    \else *\z@
    \fi
  \fi}

\def\FN@fuzzyor#1#2{(\p@-(\p@-(#1))*(\dimexpr\p@-(#2))/\p@)}

\def\FN@magicglue#1#2#3#4#5#6{%
%<trace> \iffoottrace\traceon\fi
  \dimen@\dimexpr\p@\FN@fuzzyeval{#1}{#2}\FN@lasthsize\relax
  \dimen@ii\dimexpr\p@\FN@fuzzyeval{#3}{#4}{\ht\z@+\dp\z@}\relax
  \dimen@\dimexpr\FN@fuzzyor\dimen@\dimen@ii
  \count@\numexpr((#6)-(#5))*\dimen@/\p@+(#5)\relax
  \xdef\FN@vfound{\the\dimexpr\FN@vfound+\dimen@}%
  \ifnum\count@>-\@M
    \penalty\count@
    \hskip\glueexpr -\parfillskip+1em minus 0.5em\relax
  \else
    \break
  \fi
  \xdef\FN@found{\number\numexpr\FN@found+\@ne}%
}

\def\@makefnbreak{\FN@magicglue
  {\footnotesep+\dp\strutbox}%
  {\footnotesep+\dp\strutbox+\baselineskip}%
  {\footnotesep+\dp\strutbox+0.5\baselineskip}%
  {\footnotesep+\dp\strutbox+2\baselineskip}{-200}{-12000}}
%    \end{macrocode}
% \cmd{\FN@removehboxes} is called with box~0 set to the next box to
% be appended to the current list (all preceding hboxes on the
% current list will have to go in front).
%    \begin{macrocode}
\def\FN@removehboxes{%
  \begingroup\setbox\z@\lastbox
    \ifhbox\z@\FN@removehboxes
      \endgroup
      \nobreak\hskip\parfillskip
      \@makefnbreak
    \else \endgroup
      \xdef\FN@vfound{\z@}%
      \xdef\FN@found{\z@}%
    \fi
  \xdef\FN@lasthsize{\the\dimexpr \ht\z@ +\dp\z@}%
  \unhbox\z@}

\def\FN@par{\unskip\nobreak\hskip\parfillskip
  \vadjust{\vskip\parskip}\break\null\kern\parindent\ignorespaces}
\def\FN@noindent{\unkern}
\def\FN@indent{\unkern{\setbox\z@\null\wd\z@\parindent\box\z@}}

\def\MFL@fnoteplain{\FN@fnotenested{plain}}
\def\MFL@fnotepara{\FN@fnotenested{para}}

\def\FN@fnotenested#1#2#3{%
  \edef\reserved@d{#1}%
  \FN@checkvariant{\edef\reserved@d}{%
    \FN@checkvariant{\FN@restylefootnote{#2}}%
    {\csname FN@fnote\reserved@d\endcsname{#2}{#3}}}}

\def\FN@checkvariant#1#2{\def\reserved@a{#1}%
  \def\reserved@b{#2}%
  \futurelet\reserved@c\FN@checkvariantii}

\def\FN@checkvariantii{%
  \ifx\reserved@c+%
    \reserved@a{plain}\expandafter\@firstoftwo
  \else\ifx\reserved@c-%
    \reserved@a{para}\expandafter\expandafter\expandafter
    \@firstoftwo
  \fi\fi
  \reserved@b}

\newcounter{FN@totalid}
\MakeSorted{FN@totalid}

\def\FN@fnoteplain{\FN@fnotecommon\vbox}
\def\FN@fnotepara{\FN@fnotecommon\hbox}

\def\FN@masterinsert{\@cclv}
%    \end{macrocode}
% \begin{macro}{\FN@id}
% \begin{macro}{\FN@master}
% \begin{macro}{\FN@slave}
% ^^A Is this still correct?
%   Here is the deal with master and slave ids: each footnote has a
%   unique master id.  This master id is also what is recorded in the
%   mark \cmd{\FN@master} in the footnote box itself, and in the mark
%   \cmd{\FN@slave} at the point of its mark.  At the point where a
%   \cmd{\FN@master} mark is placed, a default \cmd{\FN@slave} mark is
%   placed also with an id that is one less than the smallest id
%   generated from a footnote that is a `descendent' of the current
%   one.  This makes it possible to distinguish any split off
%   subordinate footnotes.  It must be noted that this sentinel slave
%   id will be the valid id of a completely unrelated footnote!  Since
%   the value is only used for determining one end of an \emph{open}
%   interval of excluded ids, this is no problem.  All subordinate
%   footnotes are numbered sequentially in the order of
%   \emph{completion}, so that any subordinate footnotes have lower
%   ids than their master.
%    \begin{macrocode}
\newcount\FN@id
\newmarks\FN@master
\newmarks\FN@slave
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%    \begin{macrocode}
\let\FN@errorstack\@empty

\def\FN@fnotecommon#1#2#3{%
  \leavevmode
  \stepcounter{FN@totalid}%
  \NCC@makemark{#3}%
  \ifnum#2<\FN@masterinsert
    \FN@colorstackbgroup\MFL@minipage
    \FN@newslot\FN@masterslot
    \count@\FN@id
    \dimen@=\dimexpr64\p@*\FN@masterinsert-\c@FN@totalid sp\relax
    \def\FN@masterinsert{#2}%
    \edef\FN@errorstack{\FN@errorstack^^J%
\FN@masterinsert\space entered in line \number\inputlineno}%
    \let\FN@boxtype=#1%
    \setbox\z@#1\bgroup
%    \end{macrocode}
% The following is for the likes of PDFTeX which has its own idea
% about how to restore a color stack.
%    \begin{macrocode}
      \let\current@color\default@color
      \FN@@color@begingroup
      \let\MFL@minipage\relax
      \let\MFL@endminipage\relax
      \normalfont\footnotesize
      \interlinepenalty\interfootnotelinepenalty
      \hsize\MFL@columnwidth \@parboxrestore
      \let\@listdepth\@mplistdepth \@mplistdepth\z@
      \@itemdepth\z@ \@enumdepth\z@
      \protected@edef\@currentlabel{\@thefnmark}%
      \ifx\FN@boxtype\vbox \noindent
      \else \FN@specific{#2}\@preparefnhtext
      \fi
      \normalcolor
      \FN@specific{#2}\@makefntext
      \iffalse\fi
      \expandafter\xdef\csname FN@ht\number#2\endcsname{\the\footnotesep}%
      \expandafter\xdef\csname FN@dp\number#2\endcsname{\the\dp\strutbox}%
      \marks\FN@master{\FN@masterslot}%
      \marks\FN@slave{\number\FN@id}%
      \nobreak
      \bgroup
        \aftergroup\FN@commonending
%    \end{macrocode}
% \cmd{\FN@commonending} will intervene before any tokens that are
% shifted in due to switching back the color stack.  Those will only
% be executed once we completely relinquish control.
%    \begin{macrocode}
        \ifx\FN@boxtype\vbox
           \rule\z@\footnotesep
        \else
          \ifx\FN@par\par\else
            \let\FN@@par\par
            \let\FN@@noindent\noindent
            \let\FN@@indent\indent
          \fi
           \everyvbox\expandafter{\expandafter\everyvbox
             \expandafter{\the\everyvbox}%
             \let\par\FN@@par
             \let\noindent\FN@@noindent
             \let\indent\FN@@indent
             \the\everyvbox}%
           \let\par\FN@par
           \let\noindent\FN@noindent
           \let\indent\FN@indent
        \fi
        \afterassignment\ignorespaces
        \expandafter\FN@fnotecommonii
      \else
    \PackageError{bigfoot}{#2 forbidden in \FN@masterinsert.}
    {Higher-placed footnotes can't be anchored in inferior ones.^^J%
    I am not putting this text in a footnote.  History:%
\FN@errorstack}%
    \rule{1em}{\ht\strutbox}%
\fi}

\def\FN@fnotecommonii#{\let\next}

%    \end{macrocode}
% Ok, color handling is a nuisance, to say the least.  Split
% footnotes need to close their color stack on the old page, and reopen
% it on the new one.  So we record the color stack state at each time
% it changes in a marks register.
%    \begin{macrocode}

\newmarks\FN@color
\def\FN@colorstackbgroup{\let\FN@savecolorstack\FN@colorstack
  \global\let\FN@colorstack\@empty
  \bgroup
  \ifdefined\FN@savecolorstack\else
    \let\FN@@set@color\set@color
    \let\FN@@reset@color\reset@color
    \let\FN@@color@begingroup\color@begingroup
  \fi
  \let\set@color\FN@set@color
  \let\reset@color\FN@reset@color
  \let\color@begingroup\FN@color@begingroup}

\def\FN@colorstackegroup{\egroup\ifx\FN@colorstack\@empty
  \global\let\FN@colorstack\FN@savecolorstack \fi}

\def\FN@colorstackfinish{\def\@elt##1##2{\FN@@reset@color##2}%
  \FN@colorstack
  \def\@elt##1##2{\noexpand\@elt{}{##2}}%
  \xdef\FN@colorstack{\FN@colorstack}%
  \let\@elt\relax
  \marks\FN@color{}}

\def\FN@reset@color{%
  \bgroup\def\@elt##1##2{\def\FN@next{##1}{\gdef\FN@colorstack{##2}}}%
    \let\FN@next\@empty
    \FN@colorstack
    \ifx\FN@next\@empty
      \FN@colorstackegroup
    \else \egroup
      \FN@@reset@color
      \marks\FN@color{\FN@colorstack}%
  \fi}

\def\FN@color@begingroup{%
  \let\reset@color\FN@@reset@color
  \let\color@begingroup\FN@@color@begingroup
  \let\set@color\FN@@set@color
  \color@begingroup}

\def\FN@set@color{\FN@@set@color
  \xdef\FN@colorstack{\@elt{\current@color}{\FN@colorstack}}%
  \marks\FN@color{\FN@colorstack}}

\def\FN@coloraftersplit#1{%
  \def\@elt##1##2{##2\def\current@color{##1}\set@color}%
  #1%
  \let\@elt\relax}

\def\FN@commonending{%
  \expandafter\expandafter\expandafter
  \expandafter\expandafter\expandafter\expandafter
  \iffalse  \FN@specific\FN@masterinsert\@makefntext\fi
  \unskip
  \ifx\FN@boxtype\vbox\@finalstrut\strutbox\fi
  \FN@colorstackfinish
  \color@endgroup
  \egroup
  \global\advance\FN@id\@ne
  \marks\FN@slave{\number\FN@id}%
  \FN@slotxdef\FN@masterslot{\number\FN@id}%
  \ifhbox\z@
    \global\setbox\FN@tempbox\copy\z@
    \setbox\tw@\@makefnvbox{\unhbox\FN@tempbox}%
    \ht\z@\dimexpr\ht\tw@+\dp\tw@-\FN@masterslot sp\relax
  \else
    \ht\z@\dimexpr\ht\z@+\dp\z@-\FN@masterslot sp\relax
  \fi
  \wd\z@\dimen@
  \dp\z@\FN@masterslot sp\relax
  \MFL@insert\FN@masterinsert{\nointerlineskip\box\z@}%
  \MFL@endminipage
  \FN@colorstackegroup
}

\dimen\footins\maxdimen
\gdef\FN@nestlist{}

\newdimen\FN@outervsize
\newskip\FN@vsize

\newbox\FN@insertions

\def\MFL@showone#1#2{\message{Box #2:}\showbox#2%
  \message{Cachebox #2:}\showbox\FN@cache#2}
\def\MFL@showall{{%
    \showboxbreadth=\maxdimen
    \showboxdepth=\tw@
    \tracingonline=\@ne
    \FN@nest@iterate\MFL@showone}}
%    \end{macrocode}
% \begin{macro}{\FN@retaindelayed}
%   This is a complex macro that removes all boxes from the current
%   list that are not to be kept for the next page.  The last such box
%   gets its id placed into \cmd{\FN@tempinfo} if that's still empty.
%   The slot specified by \cmd{\count@} is not freed when encountered,
%   all others are freed upon removing the box.  The last box is
%   returned in box~0 if any is retained.  The vertical list might
%   have an unchecked part locked off in front by placing a
%   \cmd{\nobreak} penalty there.  This penalty is removed, and the
%   list before it not touched.
%    \begin{macrocode}
\def\FN@retaindelayed{%
  \setbox\z@\lastbox
  \ifcase
    \ifvoid\z@\m@ne\fi \FN@config\z@
    \ifx\FN@tempinfo\@empty
      \xdef\FN@tempinfo{\FN@slotget{\number\dp\z@}}%
    \fi
    \ifnum\dp\z@=\count@\else \FN@freeslot{\number\dp\z@}\fi
    \FN@retaindelayed
  \or  {\FN@retaindelayed \nointerlineskip \box\z@}%
  \else \unpenalty \setbox\z@\lastbox
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\MFL@processplain}
%   This gets called for actually inserting the processed material
%   into the footnote box.  The current state of affairs is that
%   \cmd{\FN@config} contains all footnotes that should get
%   transferred to the next page completely.  The cache boxes contain
%   the collected and typeset footnotes for typesetting on the current
%   page.
%
%   The structure of a cachebox is currently as follows: it is filled
%   with vboxes containing the arranged material, optionally followed
%   by another box to be carried over to the next page flagged with a
%   \cmd{\nobreak} penalty.
%    \begin{macrocode}
\def\MFL@processplain#1{%
   \ifvoid\FN@cache#1%
     \global\setbox\FN@tempbox\vbox\bgroup
       \unvbox#1%
       \count@\z@
       \let\@elt\FN@removecheck \FN@retaindelayed
       \ifvoid\z@ \egroup
       \else \nointerlineskip \box\z@ \egroup
         \MFL@realinsert{#1}{\unvbox\FN@tempbox}%
       \fi
     \expandafter\expandafter
   \fi\iffalse\fi
   \global\setbox#1\vbox\bgroup%
     \unvbox\FN@cache#1%
     \ifnum\lastpenalty>\z@
       \unpenalty
       \setbox\z@\lastbox
     \else
       \setbox\z@\box\voidb@x
     \fi
     \count@\dp\z@
     \global\setbox\FN@tempbox\vbox\bgroup
       \box\z@
       \nobreak
       \unvbox#1%
       \let\@elt\FN@removecheck \FN@retaindelayed
       \ifvoid\z@ \egroup \MFL@removevboxes\egroup
       \else \nointerlineskip \box\z@ \egroup
         \MFL@removevboxes \egroup
         \MFL@realinsert{#1}{\unvbox\FN@tempbox}%
       \fi}

\let\MFL@processpara\MFL@processplain

%    \end{macrocode}
% \end{macro}
% Ok, here is the bit about the caches: whenever we encounter a new
% configuration, we have to first update the caches since we don't
% know the sizes we are dealing with regarding the new configuration
% until we do so.  The caches are kept up to date globally.  When we
% are working at several levels in the recursion, we have a bottom
% active level where we may are looking for a way to find a best
% underfull box and configuration.  We will return at most one
% configuration once we are finished: the best underfull one if
% available, or an overfull one.  If a deeper level at any point of
% time returns an overfull configuration, we are finished.  The best
% configuration to be returned is the least underfull.  If there is
% none, the least overfull.  The case of no underfull at all can only
% happen if even splitting this and every subordinate level to minimal
% height and recursing does not yield an underfull.  At every level,
% we need to maintain just a current split, and the previous best
% split at most.
%
% When we change a configuration on recursing, we have to remember the
% configurations for the previous best split.  We can manage that by
% sweeping the current cache values into a local box register
% before recursing with a different configuration: we have to rebuild
% the box registers for a different configuration, anyway.  We don't
% save the configuration from an overfull setting: when we rework the
% list in slow motion mode, we can't help stopping the recursion by
% reaching an overfull setting that is at least as good as the
% initial one.
%
% When we return to a caller, we leave the cache in the configuration
% of the best choice up to now: either we are returning an overfull
% configuration and if it is not the best so far, the caller can
% restore his better choice from his copy, or we are returning an
% underfull configuration in which case the caller might still want
% to improve upon it before returning to its caller in turn.  At the
% current grouping level we empty out our current cache and keep it
% for working purposes on the stack until we return (nobody
% references it while we are working on it).  We always enter with an
% overfull configuration, meaning that \cmd{\FN@vsize} is negative.
% It is calculated with the current cache\slash config setting.
%
% There is a danger of overflow involved with that: if we keep a swept
% complete configuration at each level of recursion, we need $O(n^2)$
% of space here.  The alternative would be to keep the history of how
% the configuration came about.  Since that might involve some
% slow-motion splitting, this is also a speed issue.  Since deep
% recursion with pending best data at each level is not really
% likely, and since we are not going to have that many footnote
% levels to go around, anyway, we just rely on \LaTeX\ having been
% started with sufficient memory.
%
% A workable compromise would be to just store the split boxes
% from a configuration together with the configuration data for
% reconstructing the rest.  After all, we don't need to reconsider
% such a configuration before actually typesetting anything.  And
% whenever we find an acceptable fit (neither underfull\slash
% overfull), we could cut through all the hierarchy without having to
% restore anything.  This has not been implemented yet: at the moment
% we go for the less complicated variation.
%
%
% The algorithm we use here is a bit complicated.  Whenever we
% recurse, we have one of the following situations:
% \begin{enumerate}
% \item An overfull/underfull dilemma: including a minimal amount of
%       material at the current level will cause the page to become
%       overfull.  This can be the case in connection with zero (in
%       case of interline penalties for larger blocks), one or more
%       subordinate footnotes and related footnotes.
% \item A pure overfull dilemma: the page was overfull to start with,
%       we need to reduce it.
% \item an underfull dilemma: some operation in the next level made
%       the page become underfull, only too much so.  We can't make it
%       fuller on the current level, but we can make it even emptier,
%       and let the next level fill it up again.
% \end{enumerate}
% ^^A
% In the current implementation, we just ignore the slight probability
% that the optimum choice might lie with case~3.  We don't
% recurse for making the page fuller again.  If we have an
% overfull/underfull dilemma, the recursion will either give us a
% less awful overfull box, or an underfull one.  An overfull box that
% occurs at the highest level of recursion can't be improved on any
% lower level.  So we never need to locally return an overfull box: we
% can compare it to the best overfull box seen before, and if we turn
% out better than that, we overwrite the global best overfull value
% and return the best local underfull if there is such a one.  The
% best local underfull will then be refilled as much as possible on
% the next level without changing the configuration.  Actually, if we
% need to change the configuration, this would also be fine as long as
% we arrive at a better underfull eventually.  But since a change of
% configuration renders our previous split completely useless, as the
% broken paragraph could look disastrously different under a changed
% configuration, we would need to recurse again.  We repeat this
% recursing operation until we don't get an underfull solution
% returned anymore.  We then return the best underfull, if any.  The
% best overfull is stored globally, as mention before.
%
% Does this sound complicated?  Unfortunately, it does.  It also
% sounds somewhat slow.  For that reason, we do a few assumptions that
% will facilitate a good average-case behavior.  The first assumption
% is that we will usually do fine by just splitting in the current
% level (if at all) and not at all in subordinate levels.
%
% We do this assumption on the first pass used for gathering the size
% information and collect the corresponding boxes in nested lists.
% When the recursion tops out, it does so either with an overfull
% page, or an underfull page.  If it does with an underfull page, we
% cache the current configuration for the next pass through the output
% routine, so that we won't need to retypeset and measure assembled
% boxes that have not gathered any new material.  If we top out with an
% overfull page, the previous underfull configuration is still worth
% keeping as well, as it might become the material actually chosen to
% be typeset.
%
% Ok, the current best configuration of the next recursion level is
% gathered on the current vertical list, in a separate box.  We use
% box~2 for this purpose.  A saved configuration consists of the
% complete contents for the current cache box without the trailing
% penalty indicating material from a single split box carried over to
% the next page (boxes that are carried over completely to the next
% page are not maintained here but rather reinserted by
% \cmd{\MFL@processnested}).  This penalty is added in case the box
% is actually disassembled and returned: there is no possibility for
% confusion since we only save such a configuration if indeed there is
% a split present.
%    \begin{macrocode}
\newtoks\FN@output
\FN@output\expandafter{\the\output}

\newbox\FN@tempbox
\newinsert\FN@savebox
\count\FN@savebox\@m
\dimen\FN@savebox\maxdimen
\skip\FN@savebox\z@skip
\global\setbox\FN@savebox\box\voidb@x

\expandafter\expandafter\expandafter\let\FN@cache\FN@savebox=\@cclv

\expandafter\def\csname FN@ht\number\FN@savebox\endcsname{\topskip}%
\expandafter\def\csname FN@dp\number\FN@savebox\endcsname{\maxdepth}

\def\FN@list{\MFL@list\@elt{}\footins}

\def\FN@sweepbox#1#2{\ifvoid#2\else
  \nointerlineskip\box#2\penalty#2\fi}

\def\FN@sweepcachebox#1#2{\nointerlineskip
  \box\FN@cache#2%
  \penalty\FN@cache#2}

\def\FN@removecheck#1#2{%
  \ifnum#1<\FN@slotget{\number\dp\z@}
  \ifnum#2>\FN@slotget{\number\dp\z@}
    \@ne\fi\fi}
%    \end{macrocode}
% Parameter recording merely records the relevant value of the
% skip register and sets it to zero.  The purpose is to avoid changes
% of the reserved page space when we collect additional material from
% a page where an insertion of the appropriate kind had already been
% encountered.  This is used for filling up underfull pages.
%    \begin{macrocode}
\def\FN@recordinsertparam#1#2{\ifvoid#2\else
  \global\skip\number#2=\the\skip#2\relax\fi}

\def\FN@clearinsertparam#1#2{\ifvoid#2\else
  \global\skip#2=\z@skip\fi}
%    \end{macrocode}
% \cmd{\FN@insertouterspace} will sum the size of the inserts manually.
%    \begin{macrocode}
\def\FN@insertouterspace#1#2{\ifvoid#2\else
    +\skip#2+(\ht#2+\dp#2)*\count#2/\@m\fi}

\def\FN@list@iterate#1{\let\FN@eltsave\@elt
  \let\@elt#1%
  \FN@list
  \let\@elt\FN@eltsave}

\def\FN@nest@iterate#1{\let\FN@eltsave\@elt
  \let\@elt#1%
  \FN@nestlist
  \let\@elt\FN@eltsave}
%    \end{macrocode}
% This is our own output routine that does all the balancing stuff.
% If we receive a forced penalty here, we must not do any of our
% output processing on our own unless this is the choice of the
% underlying output routine.  We do want to have the `real' output
% routine to have a correct idea about the size that the insertions
% will take up.  So the steps that we \emph{will} actually perform in
% any case are sorting the insertions and calculating their real
% size.  If we have not had a forced penalty, we are free to exit the
% output routine for gathering further material as there are no
% expections of the underlying output routine when it should get
% called.  If we encountered a forced penalty, things are getting more
% complicated.  If the current page happens to be overfull after
% adding the current material, we first need to ship out the material
% for a regular page (after splitting off the necessary material for
% the next page).  We then reinsert the remaining split insertions,
% any possibly split off page material and the penalty.
% Unfortunately, this is not sufficient: the penalty might have been
% inserted with a box immediately preceding it.  In that case the
% penalty would have been guaranteed to eventually turn up in the
% output routine.  If we now reinsert merely all of the above stuff,
% the penalty will just disappear.  If we protect the penalty by
% placing an empty box before it when none of it had been before it
% before, we will get an empty page.  Since we don't know whether the
% penalty was supposed to disappear at the start of an empty page or
% not, we will do the following: if the rest of |\box255| is nonvoid,
% we just reinsert the split insertions followed by the rest of
% \box255 and the penalty and return.  If it is void, we call the
% regular output routine, capturing its output in a |\vbox| of its
% own.  If the regular output routine failed to ship out the prepared
% insertions, we just keep the original data either in their boxes or
% in a reinserted insertion.

% What we actually do for this reason is
% to do all the necessary calculations and store the result in the box
% |\FN@processedboxes|.  They will then be inserted

% It hides the relevant information from the `real' output routine
% until such a time that we have enough material gathered to produce a
% full page.  The exception to this is when we have a special penalty
% that gets passed through to the regular output routine.
%
% If we are on a material collecting spree, \cmd{\FN@savebox} contains
% all boxes from the last output call time.  At the point where we
% enter the output routine, \cmd{\FN@vsize} contains the amount of
% space available for mounting footnotes, after subtracting all
% insertions of footnote variety.  At most times in our output
% routine, the variable will contain the amount of space left after
% everything is put to the page including footnotes.
%    \begin{macrocode}
\savingvdiscards=\@ne
%    \end{macrocode}
% We have the following situations that can cause us to enter the
% output routine:
% \begin{enumerate}
% \item The page has just filled up.
% \item A magic output penalty has been encountered.
% \item We are filling up a previously underfull page.
% \item We are looking for missing insertions that may have floated.
% \end{enumerate}
%
% In the situation where the page break has already been determined
% (magic output penalty, looking for missing insertions), we are not
% interested in `foreign' insertions like floating figures.  The
% current code does not cater for them.
%    \begin{macrocode}
\def\FN@lowestslave{0}

\output{%
%  \ifnum\c@page=10 \traceon\fi
  \ifvoid\FN@savebox
    \global\FN@outervsize\ht\@cclv\relax
    \global\setbox\@cclv\vbox{\unvbox\@cclv\boxmaxdepth\maxdepth}%
    \global\advance\FN@outervsize-\ht\@cclv\relax
  \else
    \dimen@\ht\@cclv
    \global\setbox\@cclv\vbox{\unvbox\@cclv\boxmaxdepth\maxdepth}%
    \global\advance\FN@outervsize\dimexpr\dimen@-\ht\@cclv\relax
%    \end{macrocode}
% Now we invalidate the cache boxes for all insertions that had
% changed due to the recent additions to the page.
%    \begin{macrocode}
    \FN@nest@iterate\FN@maybeinvalidatecache
%    \end{macrocode}
% We now update all boxes with the new data we collected    
%    \begin{macrocode}
    \vskip\z@skip
    \unvbox\FN@savebox
    \loop
      \count@\lastpenalty
    \ifnum\count@>\z@
      \unpenalty
      \setbox\z@\lastbox
      \global\setbox\count@\vbox{\unvbox\z@\unvbox\count@}%
    \repeat
    \count@\outputpenalty
    \FN@vsadjustlist
    \ifnum\count@=-13749
      \global\setbox\@cclv\lastbox
      \unskip
      \ifnum\outputpenalty<\@M \penalty\outputpenalty\fi
      \pagediscards
      \global\outputpenalty\@M
    \else
      \setbox\z@\lastbox
      \unskip
      \dimen@\dimexpr\ht\z@+\ht\@cclv
      \global\setbox\@cclv\vbox{\unvbox\z@
        \ifnum\outputpenalty<\@M \penalty\outputpenalty\fi
        \pagediscards\unvbox\@cclv
      \boxmaxdepth\maxdepth}%
      \global\outputpenalty\count@
      \global\advance\FN@outervsize\dimexpr\dimen@-\ht\@cclv
    \fi
%    \end{macrocode}
% Ok, now reset the relevant parameters to the stored values.
%    \begin{macrocode}
  \fi
  \gdef\FN@config{}%
  \FN@nest@iterate\FN@sortinsert
  \FN@nest@iterate\FN@regeneratecache
  \FN@nest@iterate{\FN@insertouterspace\global\FN@vsize\dimexpr\z@}%
  \FN@nest@iterate{\FN@cachesize\skip@\glueexpr\z@skip}%
  \global\advance\FN@vsize\glueexpr\FN@outervsize-\skip@\relax
  \ifcase
    \ifnum\insertpenalties=\z@ \else \@ne\fi
    \ifdim\ht\@cclv>\z@ \else \@ne\fi
    \ifdim\FN@vsize<\glueshrink\FN@vsize \tw@ \fi
%    \end{macrocode}
% page is overfull.  If there are no missing insertions, try to split.
% Else gather more material.
%    \begin{macrocode}
    \ifdim\FN@vsize>-\gluestretch\FN@vsize
      \ifdim\dimexpr\FN@vsize-\normalbaselineskip<\glueshrink\FN@vsize
      \else
%    \end{macrocode}
% page is underfull, and the free space is at least that of a single
% line.  If we have no special output penalty, gather more material
%    \begin{macrocode}
        \ifnum\outputpenalty>-\@M \@ne\fi
      \fi
    \fi\z@
%    \end{macrocode}
% page has appropriate size or we have special penalty.
%    \begin{macrocode}
    \gdef\FN@config{}%
    \count@\vbadness
    \vbadness\maxdimen
    \global\setbox\@cclv\vbox
      spread\FN@vsize{\unvbox\@cclv\boxmaxdepth\boxmaxdepth}%
    \vbadness\count@
    \the\FN@output
    \FN@nest@iterate\FN@clearcache
  \or
%    \end{macrocode}
% we need additional material
%    \begin{macrocode}
    {\let\@elt\FN@recordinsertparam
     \xdef\FN@vsadjustlist{\global\vsize=\the\vsize
       \global\topskip=\the\topskip
       \global\outputpenalty=\the\outputpenalty\relax
       \FN@list}%
     \let\@elt\FN@clearinsertparam
     \FN@list}%
    \global\topskip-\maxdimen\relax
    \dimen@\ht\@cclv
    \global\setbox\FN@savebox\vbox{%
      \box\@cclv
      \FN@list@iterate\FN@sweepbox}%
    \ifdim\FN@vsize<\glueshrink\FN@vsize
      \ifdim\dimen@>\z@
        \hrule\@height\z@\@depth\z@
        \penalty -13749
        \global\vsize=0.5\maxdimen
      \else
        \global\vsize=3\normalbaselineskip
      \fi
    \else
      \global\vsize=\dimexpr\FN@vsize-\glueshrink\FN@vsize\relax
    \fi
    \global\advance\FN@outervsize-\vsize\relax
    \global\deadcycles\z@
  \else
%    \end{macrocode}
% Fake our output box into something looking like a cache box
%    \begin{macrocode}
    \edef\FN@masterid{\number\maxdimen}%
    \def\FN@masterslot{-1}%
    \global\setbox\@cclv\vbox{%
      \box\@cclv}%
    \gdef\FN@config{}%
    \global\setbox\FN@savebox\vbox{}%
    \gdef\FN@badness{0}%
    \edef\FN@bestebadness{\number\maxdimen}%
    \edef\FN@defaultpenalty{\ifnum\outputpenalty<\@M
        \number\outputpenalty
      \else
        0\fi}%
    \let\@elt\FN@newlevel
    \@elt{}\FN@savebox\FN@nestlist\FN@mainsplitreturn
    \def\next{0}%
    \def\@elt#1#2{\ifnum\next<#1\relax
      \def\next{#1}%
      \fi}%
    \FN@config
    \ifnum\next>\z@
      \global\let\FN@lowestslave\next
    \fi
    \let\@elt\relax
    \global\setbox\FN@savebox\box\voidb@x
    \count@\vbadness
    \vbadness\maxdimen
    \global\setbox\@cclv\vbox spread\FN@vsize{%
      \unvbox\@cclv
      \ifnum\lastpenalty>\z@
        \unpenalty
        \global\setbox\FN@tempbox\lastbox
      \else
        \global\setbox\FN@tempbox\box\voidb@x
      \fi
      \MFL@removevboxes
      \boxmaxdepth\maxdepth}%
    \vbadness\count@
    \ifvoid\FN@tempbox\else
      \unvbox\FN@tempbox
      \ifnum\outputpenalty<\@M\penalty\outputpenalty\fi
    \fi
    \let\@elt\relax
    \the\FN@output
    \FN@nest@iterate\FN@clearcache
  \fi}
%    \end{macrocode}
% Ok, here is the deal.  If the \cmd\FN@truevsize is negative, we have
% an overfull vbox at our hand.  We then start the splitting action.
% We take the first non-split lowest footnote block and split it to
% size, removing subordinate footnotes that we would not be able to
% maintain.  We do this recursively starting by the top footnote
% block.  It must be noted that it would be even better to start with
% the highest-numbered footnote (which corresponds to the latest
% finished footnote in \emph{logical} order, that in the source code),
% but then we get the problem that we might have to remove boxes from
% a footnote block that has already been split, and that is
% troublesome (to put it mildly) in case where the footnote block is
% set in paragraph mode.  It's bad enough backtracking in a fixed
% order across footnote blocks, going back and forward would be pretty
% tough.
%
% So our recursion just walks the footnote blocks once top to bottom,
% splitting and removing boxes that are not needed.  When we recurse,
% we have a dichotomy between current overfull and underfull boxes.
% At each recursion level, we enter with an overfull configuration
% that establishes the breakable section for the footnote block in
% question.  We then construct the footnote block and try splitting it
% to size.  If this
% gives us a \emph{good} underfull version, we return that (and break
% out of recursion altogether).  Otherwise we remember the underfull
% version before the break and recurse on the overfull version.  If
% this returns an overfull version again, we return the underfull
% version before the break.  If it returns an underfull version, we
% fill up the underfull version as much as possible without a change
% of configuration, then select the best of the last underfull and
% this as new local underfull.  We then take the first overfull
% combination (even allowing a change of configuration), throw away
% the previous split in the next recursion level and recurse on the
% now thoroughly overfull combination again.
%
% When recursion tops out, we compare the current overfull with the
% previous one and record the best.  We prefer keeping an older
% overfull, all other things being equal.
%
% Ok, so what are the data structures we maintain when going through
% all this folderol?
%
% We let the insertion boxes themselves remain untouched: that makes
% it only a bit more complicated to maintain and access the relevant
% boxes, but it might come handy at one time when somebody wants to
% implement recursion that is not strictly top-to-bottom.
%
% Instead we return the relevant information in the cache boxes.  The
% total size of the cache boxes may not correspond to their actual
% contents: in case a split box intended for the next page is stored
% within them, its height is deducted from the total height of the
% cache box (and, consequentially, from \cmd{\FN@vsize}).
%
% \cmd{\FN@vsize}, the amount of free space on the current page, is
% only updated when changing levels of recursion.  Instead we work
% with \cmd{\FN@myvsize} in our iterations here, which is set to the
% absolute maximum of material from this footnote admissable to the
% page.
%
% What about the penalties and badness we collect?  An unsplit
% footnote block carries a penalty of~0 (so we need not take into
% account unsplit footnote blocks at all during our bookkeeping, as
% they are neutral), a split footnote block is prepenalized with a
% penalty of~10000, plus the badness of the split, plus any penalties
% associated with the split (limited to the $[-10000\ldots10000]$
% range).  This means that no operation on other footnote blocks can
% lower an already accumulated score.  This in turn means that we can
% prune any operations leading to a worse score than the preceding
% best score without having to actually recurse.
%
% This strategy will usually buy us a minimum number of split
% footnotes (since the penalty of~10000 is not easy to compensate)
% and corresponds rather closely to \TeX's own idea of footnote
% splitting.

% The following routine will analyze a box where the results from
% \cmd{\splitdiscards} are stored and return the penalty associated
% with the breakpoint in the global macro \cmd{\FN@breakpenalty}.
%    \begin{macrocode}
\def\FN@getbreakpenalty#1{{\setbox\z@
    \vbox{\unvcopy#1%
      \count@\FN@defaultpenalty
      \FN@getbreakpenaltyii
      \xdef\FN@breakpenalty{\number\count@}%
    }}}

\def\FN@getbreakpenaltyii{%
  \ifcase
    \ifnum\lastnodetype<\z@ \m@ne\fi
    \ifnum\lastnodetype<11 \@ne\fi
    \ifnum\lastnodetype>13 \@ne\fi
    \numexpr\lastnodetype-9\relax
  \or
    \PackageError{bigfoot}{Illegal node type}{This can't happen}%
  \or
    \count@\z@ \unskip \expandafter\FN@getbreakpenaltyii
  \or
    \count@\z@ \unkern \expandafter\FN@getbreakpenaltyii
  \or
    \count@\lastpenalty
    \unpenalty \expandafter\FN@getbreakpenaltyii
  \fi}

\def\FN@mainsplitreturn{}

\newdimen\FN@myvsize
\newcount\bigfoottolerance
\bigfoottolerance=100

\def\FN@getbadness#1{%
  {\hfuzz\maxdimen\hbadness\maxdimen\setbox\z@\hbox to\z@{\hskip-#1}}}

\def\FN@newlevel#1#2#3\FN@mainsplitreturn{%
  \count@\FN@cache#2%
  \ifvoid\count@
%     \message{Page=\thepage #2 is empty, recursing with
%   \the\FN@vsize^^J}%
%     \message{Config=\FN@config^^J}%
      #3\FN@mainsplitreturn
%     \message{Page=\thepage #2 was empty, returning with \the\FN@vsize^^J}%
%     \message{Config=\FN@config^^J}%
  \else
%<trace> \iffoottrace\message{Entering #2 with \FN@badness}\fi
    {\def\FN@currentinsertion{#2}%
     \def\FN@currentrecursion{#3}%
     \let\FN@entryconfig\FN@config
     \let\FN@entrybadness\FN@badness
     \splittopskip\csname FN@ht\number#2\endcsname\relax
     \splitmaxdepth\csname FN@dp\number#2\endcsname\relax
     \vbadness=\maxdimen
     \vfuzz\maxdimen
     \let\@elt\relax
     \expandafter\FN@newleveli\expandafter}%
%<trace> \iffoottrace\message{Exiting #2 with \FN@badness}\fi
  \fi}

\def\FN@newleveli{%
%    \end{macrocode}
% \cmd{\FN@vsize} already includes the size of the complete unsplit
% insertion.  When we recurse, it has to reflect the correct size at
% the time of recursion.  Rounding error problems don't permit us to
% accumulate any sizes in \cmd{\FN@vsize} from processing our current
% insertion, so we just subtract the whole insertion-related
% content.  We'll add stuff into it when recursing.
%    \begin{macrocode}
    \dimen@\dimexpr\ht\count@+\dp\count@\relax
    \global\advance\FN@vsize\dimexpr \dimen@
      *\count\FN@currentinsertion/\@m\relax\relax
%    \end{macrocode}
% Ok, now we are typesetting and collecting the best box.  Notice
% that we \emph{don't} exit this \cmd{\setbox} command until we have
% found the best possible split.  What we \cmd{\unvbox} here, stays
% dormant except for the last box.  When we collect configurations
% from cache boxes, we don't collect anything from our current box
% that is being assembled.
%    \begin{macrocode}
    \global\setbox\count@\vbox\bgroup\unvbox\count@
      \edef\FN@bestconfig{\FN@entryconfig}%
      \edef\FN@bestvsize{-\the\maxdimen}%
      \setbox\tw@\box\voidb@x
      \setbox\z@\lastbox
%    \end{macrocode}
% The last box may now be split.  First we note its main id.  Then we
% include its size into \cmd{\FN@vsize} as we have this much additional
% space available.
%    \begin{macrocode}
      \FN@myvsize=\dimexpr(\FN@vsize-\glueshrink\FN@vsize)%
        *\@m/\count\FN@currentinsertion-\dimen@+\ht\z@+\dp\z@\relax
%    \end{macrocode}
% Ok, first attempt.  One interesting feature is that we will never
% have to rewind the boxes from a split: we can always just glue the
% box together again.  And apart from tentative splits which we might
% revert if they cause a configuration change, we will not have to
% bother about contributing too much.  What we put in the box here
% can stay.
%
% First we split to the remaining size.  After having done so, we
% continue splitting until we get the necessary mark of the last
% footnote into our grasp: we can't split before that.
%    \begin{macrocode}
      \ifnum\FN@currentinsertion=\FN@savebox
      \else
        \def\FN@defaultpenalty{-\@M}%
        \edef\FN@masterslot{\number\dp\z@}%
        \edef\FN@masterid{\FN@slotget\FN@masterslot}%
      \fi
      \nointerlineskip
      \vbox\bgroup
        \setbox4\box\voidb@x
        \ifnum\FN@currentinsertion=\FN@savebox
          \setbox\tw@\vsplit\z@ to\dimexpr\FN@myvsize-\splitmaxdepth\relax
        \else
          \loop
            \setbox\tw@\vsplit\z@ to\dimexpr\FN@myvsize-\splitmaxdepth\relax
          \ifnum0\splitbotmarks\FN@master=\FN@masterslot
          \else
            \FN@contribute@tw@
          \repeat
        \fi
%    \end{macrocode}
% All of the above was necessary to ensure that we actually have the
% beginning of the relevant footnote in our material.  From now on,
% we are dealing with legal splits.
% Ok, now we have to check whether the subordinate configuration has
% changed.
%    \begin{macrocode}
        \edef\FN@slaveid{\splitbotmarks\FN@slave}%
        \ifx\FN@slaveid\@empty
          \let\FN@slaveid\FN@lowestslave%
        \fi
        \FN@contribute@tw@
        \ifnum\numexpr\FN@slaveid+\@ne<\FN@masterid
          \let\FN@next\FN@slaveid
        \else
          \let\FN@next\@empty
        \fi
%    \end{macrocode}
% At this point of time, we have \cmd{\FN@masterid} set properly for
% our purposes.  \cmd{\FN@slaveid} is by necessity not empty.  If any
% footnote has had its mark broken off, its id must be in the open
% range between \cmd{\FN@slaveid} and \cmd{\FN@masterid}.  So a
% nonempty value of \cmd{\FN@next} at this point of time indicates
% that we have to cater for a different configuration rather than the
% currently cached one.
%    \begin{macrocode}
        \FN@splitfurther}
%    \end{macrocode}
% Main label for reconsideration
% We are after a split to size without configuration change, or a
% split that caused a configuration change and was reverted for a slow
% motion split.  So whatever we do now up to the next configuration
% change will happen in slow motion.
%    \begin{macrocode}
\def\FN@splitfurther{%
  \ifx\FN@next\@empty
  \else
%    \end{macrocode}
% Ok, we had a compulsory change in configuration.  Reconfigure.
%    \begin{macrocode}
    \let\FN@slaveid\FN@next
    \FN@myvsize\dimexpr\FN@myvsize-%
      (\FN@vsize-\glueshrink\FN@vsize)*\@m/\count\FN@currentinsertion\relax
    \xdef\FN@config{%
      \@elt{\FN@slaveid}%
        {\FN@masterid}%
      \FN@entryconfig}%
    \let\@elt\FN@reconfig
    \FN@currentrecursion
    \let\@elt\relax
    \FN@myvsize\dimexpr\FN@myvsize+%
      (\FN@vsize-\glueshrink\FN@vsize)*\@m/\count\FN@currentinsertion\relax
  \fi
  \FN@getbreakpenalty4%
  \xdef\FN@badness{\number\numexpr\FN@entrybadness+\@M+\FN@breakpenalty}%
  \let\FN@next\FN@breakpenalty
%    \end{macrocode}
% No point in recursing if we can't beat the current best one.
%    \begin{macrocode}
  \ifnum\FN@badness<\FN@bestebadness
%    \end{macrocode}
% are we overfull?  If so, recurse once for getting better.
%    \begin{macrocode}
    \ifdim\FN@myvsize<\z@
      \advance\FN@myvsize-\dimexpr
        (\FN@vsize-\glueshrink\FN@vsize)%
         *\@m/\count\FN@currentinsertion\relax
      \global\advance\FN@vsize\dimexpr\FN@myvsize
        *\count\FN@currentinsertion/\@m\relax\relax
      \let\@elt\FN@newlevel
      \FN@currentrecursion\FN@mainsplitreturn
      \let\@elt\relax
      \global\advance\FN@vsize-\dimexpr\FN@myvsize
        *\count\FN@currentinsertion/\@m\relax\relax
      \advance\FN@myvsize\dimexpr
        (\FN@vsize-\glueshrink\FN@vsize)%
        *\@m/\count\FN@currentinsertion\relax
    \fi
  \fi
  \global\let\FN@breakpenalty\FN@next
  \xdef\FN@badness{\number\numexpr\FN@badness-\FN@breakpenalty}%
%    \end{macrocode}
% At this point of time, everything to get an overfull box averted has
% been attempted already.  Any material that would be taken over from
% the next page will add at least a full line height to what we have
% already, so we don't bother unless we have room for that.
%    \begin{macrocode}
  \ifdim\FN@myvsize<\dimexpr\splitmaxdepth+\splittopskip\relax
    \skip@\glueexpr\FN@vsize+(\dimexpr\FN@myvsize
      -(\FN@vsize-\glueshrink\FN@vsize)%
       *\@m/\count\FN@currentinsertion)%
     *\count\FN@currentinsertion/\@m\relax
    \FN@getbadness\skip@
    \expandafter\FN@returnbest
  \else
    \expandafter\FN@addmaterial
  \fi}

\def\FN@returnbest{%
  \skip@\FN@bestvsize\relax
  \dimen@\dimexpr\FN@vsize+(\dimexpr\FN@myvsize
      -(\FN@vsize-\glueshrink\FN@vsize)%
       *\@m/\count\FN@currentinsertion)%
     *\count\FN@currentinsertion/\@m\relax
  \ifnum\badness>\@M
%    \end{macrocode}
% Overfull boxes are considered terrible.
%    \begin{macrocode}
    \def\FN@ebadness{\number\numexpr\maxdimen-\@ne}%
  \else
    \ifnum\badness=\@M
      \edef\FN@ebadness{\number\numexpr\maxdimen-\tw@}%
    \else
      \edef\FN@ebadness{\number\numexpr\FN@badness+\FN@breakpenalty+\badness}%
    \fi
  \fi
  \ifcase
    \ifnum\FN@bestebadness<\FN@ebadness \@ne\fi
    \ifnum\FN@bestebadness>\FN@ebadness \tw@\fi
    \ifdim\dimen@<\z@
%    \end{macrocode}
% Among the overfull boxes, the least overfull is king.
%    \begin{macrocode}
      \ifdim\skip@>\dimen@ \@ne \fi \tw@
    \fi
%    \end{macrocode}
% Among the equally bad underfull boxes, prefer the fuller one.
%    \begin{macrocode}
    \ifdim\skip@<\dimen@ \@ne \fi \tw@
  \or
%    \end{macrocode}
% We have an earlier contender.
%    \begin{macrocode}
    \global\let\FN@config\FN@bestconfig
    \global\FN@vsize\FN@bestvsize
    \global\let\FN@badness\FN@bestbadness
    \egroup
%    \end{macrocode}
% Remove the currently typeset box from the list.
%    \begin{macrocode}
    \setbox\z@\lastbox
%    \end{macrocode}
% Restore the saved configuration.
%    \begin{macrocode}
    \nointerlineskip
    \vbox{%
      \unvbox\tw@
      \loop
        \count@\lastpenalty
      \ifnum\count@>\z@
        \unpenalty
        \global\setbox\count@\lastbox
      \repeat
      \unkern
%    \end{macrocode}
% Move the split-off box intended to be carried to the next page into
% box~\cmd{\FN@tempbox}.
%    \begin{macrocode}
      \global\setbox\FN@tempbox\lastbox
      \setbox\z@\lastbox
      \ifvoid\z@
        \unvbox\FN@tempbox
      \else
        \unvbox\z@
        \ifx\FN@bestsplitcolors\@empty\else
          \dimen@\dp\FN@tempbox
          \global\setbox\FN@tempbox\vbox{%
            \FN@coloraftersplit\FN@bestsplitcolors
            \nointerlineskip\nobreak
            \unvbox\FN@tempbox}%
          \ht\FN@tempbox
            \dimexpr\ht\FN@tempbox+\dp\FN@tempbox-\dimen@\relax
          \dp\FN@tempbox\dimen@
      \fi\fi}%
  \else
    \xdef\FN@badness{\number\numexpr\FN@badness+\FN@breakpenalty}%
    \global\advance\FN@vsize\dimexpr(\FN@myvsize
      -(\FN@vsize-\glueshrink\FN@vsize)%
       *\@m/\count\FN@currentinsertion)%
     *\count\FN@currentinsertion/\@m\relax\relax
%    \end{macrocode}
% Now box~0 is the box we need to carry to the next page.  Prepare
% the box into box~\cmd{\FN@tempbox}.
%    \begin{macrocode}
    \ifnum\FN@currentinsertion=\FN@savebox
    \else
      \ifvoid\z@\else
        \setbox\z@\vbox{\marks\FN@master{\FN@masterslot}%
          \marks\FN@slave{\FN@slaveid}%
          \FN@coloraftersplit\FN@splitcolors
          \nobreak
          \unvbox\z@}%
        \wd\z@\maxdimen
        \ht\z@\dimexpr\ht\z@+\dp\z@-\FN@masterslot sp\relax
        \dp\z@ \FN@masterslot sp\relax
      \fi
    \fi
    \global\setbox\FN@tempbox\box\z@
    \egroup
  \fi
%    \end{macrocode}
% If nothing is to be carried over, we just finish our assignment to
% the cache box and return.
%    \begin{macrocode}
  \ifvoid\FN@tempbox \egroup
%    \end{macrocode}
% If not, we add the carried-over box to the list, flag it with a
% \cmd{\nobreak}, and subtract its size from the finished box.
%    \begin{macrocode}
  \else
    \FN@carriedegroup\FN@tempbox
  \fi
}

\def\FN@carriedegroup#1{\dimen@-\dimexpr\ht#1+\dp#1\relax
  \nointerlineskip\box#1%
  \nobreak
  \expandafter\egroup
  \expandafter\ht\expandafter\count@\expandafter\dimexpr
  \the\dimen@+\ht\count@\relax}

\def\FN@addmaterial{%
  \setbox\tw@\vsplit\z@ to\dimexpr\FN@myvsize-\splitmaxdepth\relax
  \ifcase\ifvoid\tw@ \@ne\fi
  \ifnum\badness>\@M \@ne\fi\z@
    \edef\FN@next{\splitbotmarks\FN@slave}%
    \ifx\FN@next\@empty
%    \end{macrocode}
% The split was successful and yields a new best underfull in our
% current configuration.
%    \begin{macrocode}
      \FN@contribute@tw@
      \expandafter\expandafter\expandafter
      \FN@recordbest
    \else
%    \end{macrocode}
% the split would result in a configuration change, so undo it and
% revert to slow motion
%    \begin{macrocode}
      \FN@uncontribute@tw@
      \expandafter\expandafter\expandafter
      \FN@slowsplit
     \fi
  \else
%    \end{macrocode}
% Oops, looks like there is nothing at all that we could contribute
% without getting overfull.  So the unsplit version is the best we can
% manage with this configuration.
%    \begin{macrocode}
    \FN@uncontribute@tw@
    \expandafter\FN@recordbest
  \fi}

\def\FN@slowsplit{\setbox\tw@\vsplit\z@ to\z@
  \edef\FN@next{\splitbotmarks\FN@slave}%
  \ifx\FN@next\@empty \FN@contribute@tw@
    \expandafter\FN@slowsplit
  \else
%<trace>    \iffoottrace
%<trace>      \message{Slowsplit in \FN@currentinsertion on \thepage^^J}%
%<trace>    \fi
    \FN@uncontribute@tw@
    \expandafter
    \FN@recordbest
  \fi}

\def\FN@recordbest{%
  \skip@\glueexpr\FN@vsize+(\dimexpr\FN@myvsize
    -(\FN@vsize-\glueshrink\FN@vsize)%
     *\@m/\count\FN@currentinsertion)%
   *\count\FN@currentinsertion/\@m\relax
  \FN@getbreakpenalty4%
  \FN@getbadness\skip@
  \ifnum\badness>\@M
    \edef\FN@ebadness{\number\numexpr\maxdimen-\@ne}%
  \else
    \ifnum\badness=\@M
      \edef\FN@ebadness{\number\numexpr\maxdimen-\tw@}%
    \else
      \edef\FN@ebadness{\number\numexpr
        \FN@badness+\FN@breakpenalty+\badness}%
    \fi
  \fi
  \dimen@\glueexpr\FN@bestvsize\relax
%    \end{macrocode}
% If the current break is satisfactory, we can just return it.
%    \begin{macrocode}
  \ifcase
    \ifnum\FN@ebadness>\bigfoottolerance
      \else \@ne\fi
%    \end{macrocode}
% If no change of configuration follows later, we can return the best
% up to now.
%    \begin{macrocode}
    \ifnum\numexpr\FN@slaveid+\@ne<\numexpr\FN@masterid\relax
      \else \@ne\fi
    \ifvoid\z@ \@ne\fi \z@
%    \end{macrocode}
% Ok, so the split was not as good as to cause us to return
% immediately, and it also was not the last opportunity for a split
% (which again would make us return immediately).
% So we check if it is at least better than the last one, in which
% case we need to replace the previous best.
%    \begin{macrocode}
    \ifcase
      \ifnum\FN@bestebadness>\FN@ebadness \@ne\fi
      \ifnum\FN@bestebadness<\FN@ebadness \tw@\fi
      \ifdim\skip@<\z@
        \ifdim\dimen@<\skip@ \@ne \else \tw@\fi
      \fi
      \ifdim\dimen@>\skip@ \@ne\fi \tw@
    \or
      \xdef\FN@tempinfo{\def\noexpand\FN@bestvsize{\the\skip@}%
        \def\noexpand\FN@bestebadness{\FN@ebadness}%
        \def\noexpand\FN@bestbadness{\number\numexpr\FN@badness+%
          \FN@breakpenalty}%
        \def\noexpand\FN@bestconfig{\FN@config}%
        \def\noexpand\FN@slaveid{\FN@slaveid}%
        \def\noexpand\FN@bestsplitcolors{\FN@splitcolors}%
        \FN@myvsize=\the\FN@myvsize\relax}%
      \global\setbox\FN@tempbox\vbox{\box4\nointerlineskip\box\z@}%
      \egroup
      \FN@tempinfo
      \setbox\z@\lastbox
%    \end{macrocode}
% Now all relevant info has been retrieved, and we collect the best
% box info in box two.  We start with the current list.  Disassembling
% \cmd{\FN@tempbox} first has the advantage that the case of box~4
% being void does not need extra treatment.
%    \begin{macrocode}
      \setbox\tw@\vbox{\unvcopy\FN@tempbox
        \setbox\tw@\lastbox \setbox4\lastbox
        \nointerlineskip\copy\z@
        \ifnum\FN@currentinsertion=\FN@savebox
          \setbox\z@\box\tw@
        \else
          \setbox\z@\vbox{\marks\FN@master{\FN@masterslot}%
            \marks\FN@slave{\FN@slaveid}%
            \nobreak
            \unvbox\tw@}%
          \wd\z@\maxdimen
          \ht\z@\dimexpr\ht\z@+\dp\z@-\FN@masterslot sp\relax
          \dp\z@ \FN@masterslot sp\relax
        \fi
        \nointerlineskip \box\z@
        \kern\z@
        \let\@elt\FN@cachesize
        \advance\FN@myvsize-\dimexpr
          (\FN@vsize-\glueshrink\FN@vsize)%
           *\@m/\count\FN@currentinsertion\relax
        \global\advance\FN@vsize\glueexpr\z@skip\FN@currentrecursion\relax
        \let\@elt\FN@sweepcachebox
        \FN@currentrecursion
        \advance\FN@myvsize\dimexpr
          (\FN@vsize-\glueshrink\FN@vsize)%
          *\@m/\count\FN@currentinsertion\relax
        \xdef\FN@tempinfo{\FN@myvsize=\the\FN@myvsize\relax}}%
      \FN@tempinfo
      \nointerlineskip
      \vbox\bgroup\unvbox\FN@tempbox \setbox\tw@\lastbox
        \setbox4\lastbox \unvbox\z@
        \setbox\z@\box\tw@
    \fi
    \loop
      \setbox\tw@\vsplit\z@ to\z@
      \edef\FN@next{\splitbotmarks\FN@slave}%
      \FN@contribute@tw@
      \ifcase
        \ifvoid\z@\@ne\fi
        \ifx\FN@next\@empty\else\@ne\fi\z@
    \repeat
    \expandafter\FN@splitfurther
  \or
    \expandafter\FN@returnbest
  \fi}
%    \end{macrocode}
% \cmd{\FN@contribute@tw@} will go from the state where we have the
% previous \cmd{\splitdiscards} in box~4 and some material split off
% from box~0 in box~2 to a state where box~2 is contributed to the
% current list, if necessary extended by a strut to achieve the
% maximal depth.
%    \begin{macrocode}
\def\FN@contribute@tw@{%
%    \end{macrocode}
% we want to contribute box~2 back without any topskip glue, so we
% manually remove any such glue by splitting an empty box off.
%    \begin{macrocode}
  \edef\FN@splitcolors{\splitbotmarks\FN@color}%
  \ifvoid4
    \setbox4\vbox{\splitdiscards}%
    \setbox\tw@\vbox{\unvbox\tw@}%
  \else
    \advance\FN@myvsize-\ht4\relax
    \unvbox4
    \setbox4\vbox{\splitdiscards}%
    \setbox\tw@\vbox{\break\unvbox\tw@}%
    {\splittopskip-\maxdimen \setbox\tw@\vsplit\tw@ to\z@}%
  \fi
%    \end{macrocode}
% Notice the effect of \TeX's special box scope rules: box~2 assigned
% just right now will be affected by the split.  The result of the
% split will be an empty box that will temporarily overwrite box~2
% within the group, but will be restored back to the split result on
% exit.  In this manner, any topskip glue will have disappeared.
% After the split, box~2 is set to the natural depth and height of
% its contents.
%    \begin{macrocode}
  \advance\FN@myvsize-\dimexpr\ht\tw@+\dp\tw@\relax
  \dimen@\dp\tw@
  \unvbox\tw@
%    \end{macrocode}
% If this depth does not reach \cmd{\splitmaxdepth}, we add a strut
% that will cause the depth to be reached exactly.  We have to remove
% the added distance from the contents of box~4 in case that this
% split will not be permanent and a need would arise to glue the stuff
% back together with following stuff from box~0.
%    \begin{macrocode}
  \ifdim\dimen@<\splitmaxdepth
    \hrule\@height-\dimen@\@width\z@\@depth\splitmaxdepth
    \advance\dimen@-\splitmaxdepth
    \setbox4\vbox{\unvbox4\vskip\dimen@}%
    \advance\FN@myvsize\dimen@
  \fi}

\def\FN@uncontribute@tw@{%
  \ifvoid\tw@ \else
  \setbox\tw@\vbox{\unvbox\tw@\splitdiscards}%
  \setbox\z@\vbox{\break\unvbox\z@}%
  {\splittopskip-\maxdimen \setbox\z@\vsplit\z@ to\z@}%
  \setbox\z@\vbox{\unvbox\tw@\unvbox\z@}\fi}
%    \end{macrocode}
% \begin{macro}{\FN@reconfig}
%   This reconfigures the insertion cache to contain only the boxes
%   that belong to this page.  If the insertion box is empty, we can
%   skip all the folderol.  If it isn't, we empty the cache box (the
%   number of which we place in \cmd{\count@}) and add its size back
%   to \cmd{\FN@vsize}.
%    \begin{macrocode}
\def\FN@reconfig#1#2{\ifvoid#2\else
  \count@\FN@cache#2%
  \ifvoid\count@\else
    \global\advance\FN@vsize
      \glueexpr(\ht\count@+\dp\count@)*\count#2/\@m+\skip#2\relax
    \global\setbox\count@ \box\voidb@x
  \fi
%    \end{macrocode}
%   Ok, now we have emptied the cache and readjusted the size.  We now
%   fill the cache by first copying the insertion into it.
%    \begin{macrocode}
  \global\setbox\count@\vbox\bgroup\unvcopy#2%
    \let\@elt\FN@removecheck
    \FN@retainkept
%    \end{macrocode}
% Now if nothing was retained, we void the cachebox.
%    \begin{macrocode}
    \ifvoid\z@ \egroup \global\setbox\count@ \box\voidb@x
%    \end{macrocode}
% Otherwise, we combine all the boxes that remain on the page.
%    \begin{macrocode}
    \else \def\FN@masterinsert{#2}%
      \FN@assembleboxes\nointerlineskip\box\z@
    \egroup
%    \end{macrocode}
% Now we just need to reduce the available size on the page by the
% height of the assembled material:
%    \begin{macrocode}
    \global\advance\FN@vsize
      -\glueexpr(\ht\count@+\dp\count@)*\count#2/\@m+\skip#2\relax
  \fi\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\FN@retainkept}
%  This relies on \cmd{\@elt} being set to \cmd{\FN@removecheck} which
%  expands to \cmd{\@ne} if |\box0| is strictly between the two values
%  from an entry of \cmd{\FN@config}, which means that it is material
%  that should get moved to the next page.  In that case, we recurse
%  while dropping the box in question.  Otherwise we keep it.
%  Recursion bottoms out when there are no boxes left.  The function
%  leaves the last retained box in box~0; if there are no boxes to be
%  retained, this will be void.
%    \begin{macrocode}
\def\FN@retainkept{%
  \setbox\z@\lastbox
  \ifcase
    \ifvoid\z@\m@ne\fi \FN@config\z@
    {\FN@retainkept \nointerlineskip \box\z@}%
  \or  \FN@retainkept
  \fi}
%    \end{macrocode}
% \end{macro}
% Well, as the last measure, we change the output routine to our new
% routine.
%    \begin{macrocode}
\let\output\FN@output
%    \end{macrocode}
% If the footnote type ``default'' has not been declared by the time
% the document starts, we do so
%    \begin{macrocode}
\AtBeginDocument{\@ifundefined{footinsdefault}%
  {\DeclareNewFootnote[plain]{default}}{}}
%    \end{macrocode}
% And since LaTeX's macros are inferior to our own (and would probably
% not match too well), we reroot them to the default footnote style.
%    \begin{macrocode}
\def\footnote{\footnotedefault}
\def\footnotemark{\footnotemarkdefault}
\def\footnotetext{\footnotetextdefault}
\def\Footnotemark{\Footnotemarkdefault}
\def\Footnotetext{\Footnotetextdefault}
\def\Footnote{\Footnotedefault}
%</style>
%    \end{macrocode}
%
% \section{Various driver files}
% The installer, in case it is missing.  If it is to be used via
% |make|, we don't specify an installation path, since
% \begin{quote}
%   |make install|
% \end{quote}
% is supposed to cater for the installation itself.
%    \begin{macrocode}
%<installer> \input docstrip
%<installer&make> \askforoverwritefalse
%<installer> \generate{
%<installer>    \file{suffix.drv}{\from{suffix.dtx}{driver}}
%<installer>    \file{bigfoot.drv}{\from{bigfoot.dtx}{driver}}
%<installer&!make>    \usedir{tex/latex/bigfoot}
%<installer>    \file{suffix.sty}{\from{suffix.dtx}{style}}
%<installer>    \file{bigfoot.sty}{\from{bigfoot.dtx}{style}}
%<installer> }
%<installer> \endbatchfile
%    \end{macrocode}
% \end{document}
%
% Local Variables:
% mode: doctex
% TeX-master: "bigfoot.drv"
% End:
