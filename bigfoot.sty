\NeedsTeXFormat{LaTeX2e}
\def\FN@next $#1: #2 #3${#2}
\ProvidesPackage{bigfoot}[\FN@next $Date: 2004/03/18 21:37:12 $
  Version \FN@next $Revision: 1.8 $]%}

% Make sure we get reasonable behavior also in the absence of perpage.sty
\ifx\@undefined\pp@label \def\pp@label{1} \fi

\DeclareOption{para}{\PackageInfo{bigfoot}{Compatibility option `para'
  has no effect:^^J
  Spacing will be guessed from `\string\@makefntext' unless^^J
  `\string\@preparefnhtext' is redefined}}

\DeclareOption{para*}{\PackageInfo{bigfoot}{Compatibility option
    `para*':^^J
    Redefining `\string\@preparefnhtext'}%
  \def\@preparefnhtext{\ifx\@thefnmark\@empty
    \else\@makefnmark\nobreak\fi}}

\DeclareOption{ruled}{\PassOptionsToPackage{ruled}{manyfoot}}

\ProcessOptions

\newif\iffoottrace
%\foottracetrue
\iffoottrace
  \errorcontextlines\maxdimen
  \showboxdepth3
  \showboxbreadth100
  \RequirePackage{trace}
\fi
\RequirePackage{manyfoot}
\RequirePackage{etex}
\RequirePackage{suffix}
\RequirePackage{perpage}

% We need the appropriate splitting parameters set for the footnote
% again.  \MFL@realinsert does that, but it has the disadvantage that
% it uses \strutbox, and that may be set to arbitrary values at the
% time the output routine is invoked.  You already have this problem
% with minipages: the split sizes will be those of the font at the end
% of the minipage instead of those at the time the footnote body was
% set up.  So we do this here, and see later for more info about how
% to do this right:

\def\MFL@reinsout#1#2{\ifvoid#2\else
    \ifnum\count\@currbox>\z@
      \advance\@pageht \ht#2%
      \advance\@pageht \skip#2%
      \advance\@pageht \dp#2%
    \fi
    \MFL@realinsert{#2}{\unvbox#2}%
  \fi
}

% Actually, I don't get the purpose of the following line in the first
% place.  But if we do need it for some reason, it is rather certain
% that we don't want this empty insert to float.  Use \MFL@realinsert,
% or set the floatingpenalty the hard way.
\def\MFL@reins#1#2{\ifvoid#2\else\insert#2{\floatingpenalty\@MM}\fi}

% The structure of the \cmd{MFL@mpinsert} box is overly complicated,
% and it is a bad idea to unpack the boxes put into it too early:
% the \cmd{\lastbox} command is pretty inefficient when the list
% before it is long due to unpacking.  So we just leave everything
% packed in its own boxes, and unpack only at the moment when we are
% reinserting.

\long\def\MFL@mpinsert#1#2{%
  \global\setbox#1\vbox{%
    \unvbox#1%\nointerlineskip
    \vbox{#2}%
  }%
}

% The trick is like with \cmd{\removehboxes}.
\def\MFL@mpreinsert#1#2{%
  \ifvoid#2\else
    \MFL@realinsert#2{\unvbox#2
      \global\setbox#2\lastbox
      \MFL@removevboxes}%
    \ifvoid#2\else
    \MFL@realinsert#2{\unvbox#2}%
    \fi
  \fi}

\def\MFL@removevboxes{\setbox\z@\lastbox
  \ifvbox\z@{\MFL@removevboxes}\fi
  \unvbox\z@}

\def\MFL@startplain#1{\global\dimen#1\maxdimen
  \@cons\FN@nestlist{{}#1}%
  \expandafter\newbox\csname FN@cache\number#1\endcsname}

\let\MFL@startpara\MFL@startplain

\expandafter\def\expandafter\FN@stripfootins\string\footins{}

\def\FN@restylefootnote#1#2{{\edef\next{%
      \noexpand\RestyleFootnote{\expandafter\FN@stripfootins
        \string#1}{#2}}\next}}

\def\RestyleFootnote#1#2{\expandafter\xdef
  \csname Footnotetext#1\endcsname{\expandafter
    \noexpand\csname MFL@fnote#2\endcsname{\csname footins#1\endcsname}}}

\AtBeginDocument{\def\@testdef #1#2#3{%
  \def\reserved@a{#3}\expandafter \ifx \csname #1@#2\endcsname
 \reserved@a  \else \@tempswatrue
 \typeout{Changed label #1/#2: \csname #1@#2\endcsname->#3}%
 \fi}}

% \cmd{\FN@sortlist} takes the current vertical list and sorts the
% contained boxes according to their width (which is supposed to
% contain the sort key).
%
% The algorithm is a pretty straightforward insertion sort with
% $O(n^2)$~steps.  This is the best one can hope for without
% comparisons across non-adjacent list elements.  For presorted lists,
% the performance will be $O(n)$, and that's what we expect to see for
% simple cases (and when there are no sortkeys yet).  Any negative
% width will certainly hang the algorithm.
%
% It also happens that \TeX\ has a hardwired limit for grouping levels
% that hits at 255.  Oops.  We better not have a few hundred footnotes
% in a single block on one page\dots

\def\FN@sortlist{{%
  \setbox\z@\lastbox
  \ifvoid\z@ \else \FN@sortlist\FN@sortlistii \fi}}

\def\FN@sortlistii{%
  \setbox\tw@\lastbox
  \ifvoid\tw@\else
  \ifdim\wd\tw@<\wd\z@ {\FN@sortlistii}%
  \fi\nointerlineskip\box\tw@\fi\nointerlineskip\box\z@}

\def\FN@sortinsert#1#2{\ifvoid\csname FN@cache\number#2\endcsname
  \ifvoid#2\else\global\setbox#2\vbox{\unvbox#2%
    \FN@sortlist}\fi\fi}

% \cmd{\FN@assembleboxes} will produce the finished product, by
% generating all boxes (not yet unpacked in order not to make the
% |\lastbox| operation inefficient as long as we may need it).  It is
% assumed that you have already set |\box\z@| to |\lastbox| before
% calling this routine (or, more likely, have already assembled and
% split the last box).  The last, not yet unpacked |\vbox| is left in
% |\box\z@| on return.  You have to take note of the depth of the
% originally last box before calling this routine, as the depth will
% not be reconstructed for the last box.
%
% The last box might have come about by joining several horizontal
% boxes, so splitting it might separate footnotes.  We deal with that
% problem at a different point of time by checking the respective Ids
% when breaking a vbox into pieces: if the split piece does not
% contain the last footnote beginning, we switch to a slow motion
% decomposal.

\def\FN@maybeinvalidatecache#1#2{%
  \ifvoid#2\else\global\setbox\csname FN@cache\number#2\endcsname
    \box\voidb@x\fi}

\def\FN@regeneratecache#1#2{%
   \global\setbox\csname FN@cache\number#2\endcsname
   \ifvoid#2%
     \box\voidb@x
   \else
     \vbox{\unvcopy#2%
       \setbox\z@\lastbox
       \def\FN@masterinsert{#2}%
       \FN@assembleboxes
       \nointerlineskip \box\z@}%
    \fi}

\def\FN@mayberegeneratecache#1#2{%
  \ifvoid\csname FN@cache\number#2\endcsname
    \FN@regeneratecache{}{#2}%
  \fi}

% This calculates the difference the size of the cache appears to make
% as compared with the original insertion.  If you think you can
% improve this by factoring out the fraction, don't.  The
% distributive law does not hold with fixed point arithmetic.  We
% avoid accumulative errors by scaling only complete boxes.
\def\FN@cachesize#1#2{%
  \ifvoid\csname FN@cache\number#2\endcsname
  \else
    +\skip#2%
    +(\ht\csname FN@cache\number#2\endcsname
      +\dp\csname FN@cache\number#2\endcsname)*\count#2/\@m
  \fi}

\def\FN@clearcache#1#2{%
  \global\setbox\csname FN@cache\number#2\endcsname\box\voidb@x}

\def\@makefnvtext#1{%
  \FN@specific\FN@masterinsert\@makefntext{%
    \vadjust{\nobreak\vskip-\baselineskip}\nobreak\hfill\break#1}}

\ifx\@preparefnhtext\@undefined
\def\@preparefnhtext{{%
  \setbox\z@\hbox{\FN@specific\FN@masterinsert\@makefntext{%
      \unskip\unpenalty\setbox\z@\lastbox
      \dimen@
        \ifnum\parshape>\z@
          \dimexpr\parshapeindent\tw@-\parshapeindent\@ne\relax
        \else \ifnum\hangafter=\@ne\hangindent \else
          \ifnum\hangafter=\m@ne -\hangindent
          \else \z@ \fi\fi\fi
      \dimen@ii\dimen@
      \ifhbox\z@ \advance\dimen@-\wd\z@
        \setbox\z@\hbox{\unhbox\z@}%
        \advance\dimen@\wd\z@
      \fi
      \xdef\FN@tempinfo{\hskip\the\dimen@
        \vadjust{}\nobreak\hskip-\the\dimen@ii\relax}}}}
  \FN@tempinfo}
\fi
% Now we have in |\FN@tempinfo| the excess width of the label we
% don't want to preserve when doing in-paragraph footnote setting.  A
% sequence of glue before a label now has to consist of stuff that
% vanishes at a breakpoint, followed by stuff that remains.
% We have to have two behaviors for the contents: behavior one is
% justification at the start of a line, behavior two is justification
% in the line.  When we are at the start of the line, preceding
% interword space disappears swallowed and so the natural criterion
% for distinguishing those cases is this initial line break.  This
% means that we can't avoid articifially adding a line break at the
% start of such a box.  We will back up its height again.  Some
% packages specify a |\hangindent| (I~know of no examples where they
% would actually set |\hangafter| to a value different from its
% default of~1, or set |\hangindent| to e negative value which would
% affect the right margin):  due to our artifical line at
% the top, the indent will actually be active for the first line
% already.  We back it out of the actual labels happening at the
% start of the line.  Two-line parshapes have the same effect: the
% first line is not actually used, and we put the relevant info for
% the first line into the label.  Different right indentation for the
% first line is something we can't simulate, but again, it should
% occur rarely.  When |\parshape| is active, |\hangindent| is ignored.

\ifx\@makefnvbox\@undefined
\def\@makefnvbox#1{\vbox{%
      \reset@font\footnotesize
      \interlinepenalty\interfootnotelinepenalty
      \hsize\MFL@columnwidth \@parboxrestore
      \noindent
      \rule\z@\footnotesep
      \advance\linepenalty500
      \let\@thefnmark\@empty
      \FN@specific\FN@masterinsert\@makefnvtext{#1}%
      \unskip\@finalstrut\strutbox
    }}
\fi

\def\hfootfraction{0.9}
\def\vtypefraction{0.6}

\def\FN@assembleboxes{%
  \ifhbox\z@
    \dimen@\dp\z@
    \dimen@ii\z@
    \setbox\tw@\box\voidb@x
    \loop \advance\dimen@ii\dimexpr\ht\z@+\dp\z@\relax
      \setbox\tw@\hbox{\box\z@\unhbox\tw@}%
      \setbox\z@\lastbox
    \ifhbox\z@
    \repeat
    {\FN@assembleboxes\nointerlineskip\box\z@}%
    \global\setbox\FN@tempbox\copy\tw@
    \setbox\z@\@makefnvbox{%
      \global\setbox\FN@tempbox
      \hbox{\unhbox\FN@tempbox\setbox\z@\lastbox\FN@removehboxes}%
      \unhbox\FN@tempbox}%
    \ifdim\FN@vfound>\dimexpr\vtypefraction\p@*\FN@found\relax
      \ifdim\dimexpr \ht\z@+\dp\z@>\hfootfraction\dimen@ii
        \global\setbox\FN@tempbox\box\tw@
        \setbox\z@\@makefnvbox{%
          \global\setbox\FN@tempbox
          \hbox{\let\@makefnbreak\break
            \unhbox\FN@tempbox\setbox\z@\lastbox\FN@removehboxes}%
          \unhbox\FN@tempbox}%
      \fi
    \fi
    \setbox\tw@\box\voidb@x
    \ht\z@\dimexpr \ht\z@+\dp\z@-\dimen@\relax
    \dp\z@\dimen@
  \else
    \ifvbox\z@{%
      \setbox\z@\lastbox
      \FN@assembleboxes\nointerlineskip\box\z@}%
    \fi
  \fi}

% Ok, so here is the magic glue calculator.  |#1| and~|#2| give the
% range over which the preceding line changes from `short' to `long'.
% |#3| and |#4| give the range over which the current line changes
% from `short' to `long'.  Both are combined with a probabilistic or
% function, and then a penalty is chosen which ranges from |#5|
% to~|#6| for short to long.

\def\FN@fuzzyeval#1#2#3{%
  \ifdim\dimexpr#3<\dimexpr(#2)\relax
    \ifdim\dimexpr#3>\dimexpr(#1)\relax
      *(\dimexpr(#3)-(#1))%
      /(\dimexpr(#2)-(#1))%
    \else *\z@
    \fi
  \fi}

\def\FN@fuzzyor#1#2{(\p@-(\p@-(#1))*(\dimexpr\p@-(#2))/\p@)}

\def\FN@magicglue#1#2#3#4#5#6{%
%  \iffoottrace\traceon\fi
  \dimen@\dimexpr\p@\FN@fuzzyeval{#1}{#2}\FN@lasthsize\relax
  \dimen@ii\dimexpr\p@\FN@fuzzyeval{#3}{#4}{\ht\z@+\dp\z@}\relax
  \dimen@\dimexpr\FN@fuzzyor\dimen@\dimen@ii
  \count@\numexpr((#6)-(#5))*\dimen@/\p@+(#5)\relax
  \xdef\FN@vfound{\the\dimexpr\FN@vfound+\dimen@}%
  \ifnum\count@>-\@M
    \penalty\count@
    \hskip\glueexpr -\parfillskip+1em minus 0.5em\relax
  \else
    \break
  \fi
  \xdef\FN@found{\number\numexpr\FN@found+\@ne}%
}

\def\@makefnbreak{\FN@magicglue
  {\footnotesep+\dp\strutbox}%
  {\footnotesep+\dp\strutbox+\baselineskip}%
  {\footnotesep+\dp\strutbox+0.5\baselineskip}%
  {\footnotesep+\dp\strutbox+2\baselineskip}{-200}{-12000}}
  
% \cmd{\FN@removehboxes} is called with box~0 set to the next box to
% be appended to the current list (all preceding hboxes on the
% current list will have to go in front).
\def\FN@removehboxes{%
  \begingroup\setbox\z@\lastbox
    \ifhbox\z@\FN@removehboxes
      \endgroup
      \nobreak\hskip\parfillskip
      \@makefnbreak
    \else \endgroup
      \xdef\FN@vfound{\z@}%
      \xdef\FN@found{\z@}%
    \fi
  \xdef\FN@lasthsize{\the\dimexpr \ht\z@ +\dp\z@}%
  \unhbox\z@}

\def\FN@par{\unskip\nobreak\hskip\parfillskip
  \vadjust{\vskip\parskip}\break\null\kern\parindent\ignorespaces}
\def\FN@noindent{\unkern}
\def\FN@indent{\unkern{\setbox\z@\null\wd\z@\parindent\box\z@}}

\def\MFL@fnoteplain{\FN@fnotenested{plain}}
\def\MFL@fnotepara{\FN@fnotenested{para}}

\def\FN@fnotenested#1#2#3{%
  \edef\reserved@d{#1}%
  \FN@checkvariant{\edef\reserved@d}{%
    \FN@checkvariant{\FN@restylefootnote{#2}}%
    {\csname FN@fnote\reserved@d\endcsname{#2}{#3}}}}

\def\FN@checkvariant#1#2{\def\reserved@a{#1}%
  \def\reserved@b{#2}%
  \futurelet\reserved@c\FN@checkvariantii}

\def\FN@checkvariantii{%
  \ifx\reserved@c+%
    \reserved@a{plain}\expandafter\@firstoftwo
  \else\ifx\reserved@c-%
    \reserved@a{para}\expandafter\expandafter\expandafter
    \@firstoftwo
  \fi\fi
  \reserved@b}

% Here is the deal with master and slave ids:  each footnote has a
% unique master id.  This master id is also what is recorded in the
% mark \cmd{\FN@master} in the footnote box itself, and in the mark
% \cmd{\FN@slave} at the point of its mark.  At the point where a
% \cmd{\FN@master} mark is placed, a default \cmd{\FN@slave} mark is
% placed also with an id that is one less than any subordinate
% footnote ids so that one can distinguish any split off subordinate
% footnotes.  It must be noted that this sentinel slave id will
% be the valid id of a completely unrelated footnote!  Since the
% value is only used for determining one end of an \emph{open}
% interval of excluded ids, no harm results from that.
% All subordinate footnotes are numbered sequentially in
% the order of \emph{completion}, so that any subordinate footnotes
% have lower ids than their master.

\def\FN@masterinsert{\@cclv}

\newcount\FN@id
\newmarks\FN@master
\newmarks\FN@slave

\global\let\FN@stacklist\@empty

\def\DefineFootnoteStack#1{%
  \global\expandafter\let\csname FN@stack@#1\endcsname\@empty
  \@cons\FN@stacklist{{#1}}%
}

\AtEndDocument{\FN@checkstacklist}

\def\FN@checkstacklist{{\let\@elt\FN@checkstack
  \FN@stacklist}}

\def\FN@checkstack#1{{\let\@elt\FN@checkstackentry
    \csname FN@stack#1@\endcsname}}

\def\FN@checkstackentry#1#2#3{%
  \PackageError{bigfoot}{Unfinished #1 #2 from line #3}%
  {The specified footnote range is uncomplete}}

\def\PushFootnoteMark#1{{\let\@elt\relax
  \expandafter\unrestored@protected@xdef \csname FN@stack@#1\endcsname
  {\@elt{#1}{\@thefnmark}{\number\inputlineno}\csname
  FN@stack@#1\endcsname}}}

\def\PopFootnoteMark#1{\expandafter
  \ifx\csname FN@stack@#1\endcsname\@empty
    \PackageError{bigfoot}{Empty footnote stack #1}%
    {The specified footnote type has no uncompleted range}%
  \else
  {\let\@elt\FN@firstpop
    \iffalse{\fi\csname FN@stack@#1\endcsname}}\fi}

\def\FN@firstpop#1#2#3{\protected@xdef\@thefnmark{#2}%
  \let\@elt\relax
  \expandafter\protected@xdef\csname FN@stack@#1\endcsname{%
    \iffalse}\fi}

\def\FN@specific#1#2{\romannumeral
  \ifcsname FN\string#2\number#1\endcsname
  \expandafter
    \z@\csname FN\string#2\number#1\expandafter\endcsname
  \else\expandafter\z@
    \expandafter#2\fi}

\def\FootnoteSpecific#1{\count@\csname footins#1\endcsname\toks@{}%
  \FN@specific@ii}

\long\def\FN@specific@ii#1#2{\toks@\expandafter{\the\toks@#1}%
  \the\expandafter\toks@
  \csname FN\string#2\number\count@\endcsname}

\WithSuffix\def\FN@specific@ii\long{\toks@\expandafter
  {\the\toks@\long}\FN@specific@ii}

\WithSuffix\def\FN@specific@ii\global{\toks@\expandafter
  {\the\toks@\global}\FN@specific@ii}

\WithSuffix\def\FN@specific@ii\expandafter{\expandafter
  \FN@specific@ii\expandafter}
  
    
\def\FN@fnoteplain{\FN@fnotecommon\vbox}
\def\FN@fnotepara{\FN@fnotecommon\hbox}

\let\FN@errorstack\@empty

\def\FN@slotfreelist{}
\def\FN@nextslot{1}

\def\FN@newslot#1{%
  \ifx\FN@slotfreelist\@empty
    \edef#1{\FN@nextslot}%
    \xdef\FN@nextslot{\number\numexpr \FN@nextslot+\@ne}%
  \else
    \let#1\FN@slotfreelist
    \xdef\FN@slotfreelist{\csname FN@slot\FN@slotfreelist\endcsname}%
  \fi
%  \iffoottrace\message{^^JAllocated #1^^J}\fi
}

\def\FN@freeslot#1{%
%  \iffoottrace\message{^^JFreeing #1^^J}\fi
  \global\expandafter\let\csname FN@slot#1\endcsname=\FN@slotfreelist
  \xdef\FN@slotfreelist{#1}}

\def\FN@slotxdef#1{%
  \global\expandafter\xdef\csname FN@slot#1\endcsname}

\def\FN@slotget#1{\csname FN@slot#1\endcsname}

\def\FN@fnotecommon#1#2#3{%
  \NCC@makemark{#3}%
  \ifnum#2<\FN@masterinsert
    \FN@colorstackbgroup\MFL@minipage
    \FN@newslot\FN@masterslot
    \count@\FN@id
    \dimen@=\numexpr64*\FN@masterinsert-\pp@label sp
    \def\FN@masterinsert{#2}%
    \edef\FN@errorstack{\FN@errorstack^^J%
\FN@masterinsert\space entered in line \number\inputlineno}%
    \let\FN@boxtype=#1%
    \setbox\z@#1\bgroup
% The following is for the likes of PDFTeX which has its own idea
% about how to restore a color stack.
      \let\current@color\default@color
      \FN@@color@begingroup
      \let\MFL@minipage\relax
      \let\MFL@endminipage\relax
      \normalfont\footnotesize
      \interlinepenalty\interfootnotelinepenalty
      \hsize\MFL@columnwidth \@parboxrestore
      \protected@edef\@currentlabel{\@thefnmark}%
      \ifx\FN@boxtype\vbox \noindent
      \else \FN@specific{#2}\@preparefnhtext
      \fi
      \normalcolor
      \FN@specific{#2}\@makefntext
      \iffalse\fi
      \expandafter\xdef\csname FN@ht\number#2\endcsname{\the\footnotesep}%
      \expandafter\xdef\csname FN@dp\number#2\endcsname{\the\dp\strutbox}%
      \marks\FN@master{\FN@masterslot}%
      \marks\FN@slave{\number\FN@id}%
      \nobreak
      \bgroup
        \aftergroup\FN@commonending
% \FN@commonending will intervene before any tokens that are shifted
% in due to switching back the color stack.  Those will only be
% executed once we completely relinquish control.
        \ifx\FN@boxtype\vbox
           \rule\z@\footnotesep
        \else
          \ifx\FN@par\par\else
            \let\FN@@par\par
            \let\FN@@noindent\noindent
            \let\FN@@indent\indent
          \fi
           \everyvbox\expandafter{\expandafter\everyvbox
             \expandafter{\the\everyvbox}%
             \let\par\FN@@par
             \let\noindent\FN@@noindent
             \let\indent\FN@@indent
             \the\everyvbox}%
           \let\par\FN@par
           \let\noindent\FN@noindent
           \let\indent\FN@indent
        \fi
        \afterassignment\ignorespaces
        \expandafter\FN@fnotecommonii
      \else
    \PackageError{bigfoot}{#2 forbidden in \FN@masterinsert.}
    {Higher-placed footnotes can't be anchored in inferior ones.^^J%
    I am not putting this text in a footnote.  History:%
\FN@errorstack}%
    \rule{1em}{\ht\strutbox}%
\fi}

\def\FN@fnotecommonii#{\let\next}

% Ok, color handling is a nuisance, to say the least.  Split
% footnotes need to close their color stack on the old page, and reopen
% it on the new one.  So we record the color stack state at each time
% it changes in a marks register.

\newmarks\FN@color
\def\FN@colorstackbgroup{\let\FN@savecolorstack\FN@colorstack
  \global\let\FN@colorstack\@empty
  \bgroup
  \ifdefined\FN@savecolorstack\else
    \let\FN@@set@color\set@color
    \let\FN@@reset@color\reset@color
    \let\FN@@color@begingroup\color@begingroup
  \fi
  \let\set@color\FN@set@color
  \let\reset@color\FN@reset@color
  \let\color@begingroup\FN@color@begingroup}

\def\FN@colorstackegroup{\egroup\ifx\FN@colorstack\@empty
  \global\let\FN@colorstack\FN@savecolorstack \fi}

\def\FN@colorstackfinish{\def\@elt##1##2{\FN@@reset@color##2}%
  \FN@colorstack
  \def\@elt##1##2{\noexpand\@elt{}{##2}}%
  \xdef\FN@colorstack{\FN@colorstack}%
  \let\@elt\relax
  \marks\FN@color{}}

\def\FN@reset@color{%
  \bgroup\def\@elt##1##2{\def\FN@next{##1}{\gdef\FN@colorstack{##2}}}%
    \let\FN@next\@empty
    \FN@colorstack
    \ifx\FN@next\@empty
      \FN@colorstackegroup
    \else \egroup
      \FN@@reset@color
      \marks\FN@color{\FN@colorstack}%
  \fi}

\def\FN@color@begingroup{%
  \let\color@reset@color\FN@@color@reset@color
  \let\color@begingroup\FN@@color@begingroup
  \let\color@set@color\FN@@color@setcolor
  \color@begingroup}

\def\FN@set@color{\FN@@set@color
  \xdef\FN@colorstack{\@elt{\current@color}{\FN@colorstack}}%
  \marks\FN@color{\FN@colorstack}}

\def\FN@coloraftersplit#1{%
  \def\@elt##1##2{##2\def\current@color{##1}\set@color}%
  #1%
  \let\@elt\relax}

\def\FN@commonending{%
  \expandafter\expandafter\expandafter
  \expandafter\expandafter\expandafter\expandafter
  \iffalse  \FN@specific\FN@masterinsert\@makefntext\fi
  \unskip
  \ifx\FN@boxtype\vbox\@finalstrut\strutbox\fi
  \FN@colorstackfinish
  \color@endgroup
  \egroup
  \global\advance\FN@id\@ne
  \marks\FN@slave{\number\FN@id}%
  \FN@slotxdef\FN@masterslot{\number\FN@id}%
  \ifhbox\z@
    \global\setbox\FN@tempbox\copy\z@
    \setbox\tw@\@makefnvbox{\unhbox\FN@tempbox}%
    \ht\z@\dimexpr\ht\tw@+\dp\tw@-\FN@masterslot sp\relax
  \else
    \ht\z@\dimexpr\ht\z@+\dp\z@-\FN@masterslot sp\relax
  \fi
  \wd\z@\dimen@
  \dp\z@\FN@masterslot sp\relax
  \MFL@insert\FN@masterinsert{\nointerlineskip\box\z@}%
  \MFL@endminipage
  \FN@colorstackegroup
}

\dimen\footins\maxdimen
\gdef\FN@nestlist{}

\newdimen\FN@outervsize
\newskip\FN@vsize

\newbox\FN@insertions

\def\MFL@showone#1#2{\message{Box #2:}\showbox#2%
  \message{Cachebox #2:}\showbox\csname FN@cache\number#2\endcsname}
\def\MFL@showall{{%
    \showboxbreadth=\maxdimen
    \showboxdepth=\tw@
    \tracingonline=\@ne
    \FN@nest@iterate\MFL@showone}}



\def\FN@retaindelayed{%
  \setbox\z@\lastbox
  \ifcase
    \ifvoid\z@\m@ne\fi \FN@config\z@
    \ifx\FN@tempinfo\@empty
      \xdef\FN@tempinfo{\FN@slotget{\number\dp\z@}}%
    \fi
    \ifnum\dp\z@=\count@\else \FN@freeslot{\number\dp\z@}\fi
    \FN@retaindelayed
  \or  {\FN@retaindelayed \nointerlineskip \box\z@}%
  \else \unskip
  \fi}

\def\FN@retainkept{%
  \setbox\z@\lastbox
  \ifcase
    \ifvoid\z@\m@ne\fi \FN@config\z@
    {\FN@retainkept \nointerlineskip \box\z@}%
  \or  \FN@retainkept
  \fi}

\def\MFL@processplain#1{%
   \ifvoid\csname FN@cache\number#1\endcsname
     \global\setbox\FN@tempbox\vbox\bgroup
       \unvbox#1%
       \count@\z@
       \let\@elt\FN@removecheck \FN@retaindelayed
       \ifvoid\z@ \egroup
       \else \nointerlineskip \box\z@ \egroup
         \MFL@realinsert{#1}{\unvbox\FN@tempbox}%
       \fi
     \expandafter\expandafter
   \fi\iffalse\fi
   \global\setbox#1\vbox\bgroup%
     \unvbox\csname FN@cache\number#1\endcsname
     \ifnum\lastpenalty>\z@
       \unpenalty
       \setbox\z@\lastbox
     \else
       \setbox\z@\box\voidb@x
     \fi
     \count@\dp\z@
     \global\setbox\FN@tempbox\vbox\bgroup
       \box\z@
       \vskip\z@skip
       \unvbox#1%
       \let\@elt\FN@removecheck \FN@retaindelayed
       \ifvoid\z@ \setbox\z@\lastbox \fi
       \ifvoid\z@ \egroup \MFL@removevboxes\egroup
       \else \nointerlineskip \box\z@ \egroup
         \MFL@removevboxes \egroup
         \MFL@realinsert{#1}{\unvbox\FN@tempbox}%
       \fi}

\let\MFL@processpara\MFL@processplain

% Ok, here is the bit about the caches: whenever we encounter a new
% configuration, we have to first update the caches since we don't
% know the sizes we are dealing with regarding the new configuration
% until we do so.  The caches are kept up to date globally.  When we
% are working at several levels in the recursion, we have a bottom
% active level where we may are looking for a way to find a best
% underfull box and configuration.  We will return at most one
% configuration once we are finished: the best underfull one if
% available, or an overfull one.  If a deeper level at any point of
% time returns an overfull configuration, we are finished.  The best
% configuration to be returned is the least underfull.  If there is
% none, the least overfull.  The case of no underfull at all can only
% happen if even splitting this and every subordinate level to minimal
% height and recursing does not yield an underfull.  At every level,
% we need to maintain just a current split, and the previous best
% split at most.
%
% When we change a configuration on recursing, we have to remember the
% configurations for the previous best split.  We can manage that by
% sweeping the current cache values into a local box register
% before recursing with a different configuration: we have to rebuild
% the box registers for a different configuration, anyway.  We don't
% save the configuration from an overfull setting: when we rework the
% list in slow motion mode, we can't help stopping the recursion by
% reaching an overfull setting that is at least as good as the
% initial one.
%
% When we return to a caller, we leave the cache in the configuration
% of the best choice up to now: either we are returning an overfull
% configuration and if it is not the best so far, the caller can
% restore his better choice from his copy, or we are returning an
% underfull configuration in which case the caller might still want
% to improve upon it before returning to its caller in turn.  At the
% current grouping level we empty out our current cache and keep it
% for working purposes on the stack until we return (nobody
% references it while we are working on it).  We always enter with an
% overfull configuration, meaning that \cmd{\FN@vsize} is negative.
% It is calculated with the current cache\slash config setting.
%
% There is a danger of overflow involved with that: if we keep a swept
% complete configuration at each level of recursion, we need $O(n^2)$
% of space here.  The alternative would be to keep the history of how
% the configuration came about.  Since that might involve some
% slow-motion splitting, this is also a speed issue.  Since deep
% recursion with pending best data at each level is not really
% likely, and since we are not going to have that many footnote
% levels to go around, anyway, we just rely on \LaTeX\ having been
% started with sufficient memory.
%
% A workable compromise would be to just store the split boxes
% from a configuration together with the configuration data for
% reconstructing the rest.  After all, we don't need to reconsider
% such a configuration before actually typesetting anything.  And
% whenever we find an acceptable fit (neither underfull\slash
% overfull), we could cut through all the hierarchy without having to
% restore anything.  This has not been implemented yet: at the moment
% we go for the less complicated variation.
%
%
% The algorithm we use here is a bit complicated.  Whenever we
% recurse, we have one of the following situations:
% \begin{enumerate}
% \item An overfull/underfull dilemma: including a minimal amount of
%       material at the current level will cause the page to become
%       overfull.  This can be the case in connection with zero (in
%       case of interline penalties for larger blocks), one or more
%       subordinate footnotes and related footnotes.
% \item A pure overfull dilemma: the page was overfull to start with,
%       we need to reduce it.
% \item an underfull dilemma: some operation in the next level made
%       the page become underfull, only too much so.  We can't make it
%       fuller on the current level, but we can make it even emptier,
%       and let the next level fill it up again.
% \end{enumerate}
% ^^A
% In the current implementation, we just ignore the slight probability
% that the optimum choice might lie with case~3.  We don't
% recurse for making the page fuller again.  If we have an
% overfull/underfull dilemma, the recursion will either give us a
% less awful overfull box, or an underfull one.  An overfull box that
% occurs at the highest level of recursion can't be improved on any
% lower level.  So we never need to locally return an overfull box: we
% can compare it to the best overfull box seen before, and if we turn
% out better than that, we overwrite the global best overfull value
% and return the best local underfull if there is such a one.  The
% best local underfull will then be refilled as much as possible on
% the next level without changing the configuration.  Actually, if we
% need to change the configuration, this would also be fine as long as
% we arrive at a better underfull eventually.  But since a change of
% configuration renders our previous split completely useless, as the
% broken paragraph could look disastrously different under a changed
% configuration, we would need to recurse again.  We repeat this
% recursing operation until we don't get an underfull solution
% returned anymore.  We then return the best underfull, if any.  The
% best overfull is stored globally, as mention before.
%
% Does this sound complicated?  Unfortunately, it does.  It also
% sounds somewhat slow.  For that reason, we do a few assumptions that
% will facilitate a good average-case behavior.  The first assumption
% is that we will usually do fine by just splitting in the current
% level (if at all) and not at all in subordinate levels.
%
% We do this assumption on the first pass used for gathering the size
% information and collect the corresponding boxes in nested lists.
% When the recursion tops out, it does so either with an overfull
% page, or an underfull page.  If it does with an underfull page, we
% cache the current configuration for the next pass through the output
% routine, so that we won't need to retypeset and measure assembled
% boxes that have not gathered any new material.  If we top out with an
% overfull page, the previous underfull configuration is still worth
% keeping as well, as it might become the material actually chosen to
% be typeset.
%
% Ok, the current best configuration of the next recursion level is
% gathered on the current vertical list, in a separate box.  We use
% box~2 for this purpose.  A saved configuration consists of the
% complete contents for the current cache box without the trailing
% penalty indicating material from a single split box carried over to
% the next page (boxes that are carried over completely to the next
% page are not maintained here but rather reinserted by
% \cmd{\MFL@processnested}).  This penalty is added in case the box
% is actually disassembled and returned: there is no possibility for
% confusion since we only save such a configuration if indeed there is
% a split present.
     
\newtoks\FN@output
\FN@output\expandafter{\the\output}

\newbox\FN@tempbox
\newinsert\FN@savebox
\count\FN@savebox\@m
\dimen\FN@savebox\maxdimen
\skip\FN@savebox\z@skip
\global\setbox\FN@savebox\box\voidb@x

\expandafter\let\csname FN@cache\number\FN@savebox\endcsname\@cclv

\expandafter\def\csname FN@ht\number\FN@savebox\endcsname{\topskip}%
\expandafter\def\csname FN@dp\number\FN@savebox\endcsname{\maxdepth}

\def\FN@list{\MFL@list\@elt{}\footins}

\def\FN@sweepbox#1#2{\ifvoid#2\else
  \nointerlineskip\box#2\penalty#2\fi}

\def\FN@sweepcachebox#1#2{\nointerlineskip
  \box\csname FN@cache\number#2\endcsname
  \penalty\csname FN@cache\number#2\endcsname\relax}

\def\FN@removecheck#1#2{%
  \ifnum#1<\FN@slotget{\number\dp\z@}
  \ifnum#2>\FN@slotget{\number\dp\z@}
    \@ne\fi\fi}

% Parameter recording merely records the relevant value of the
% skip register and sets it to zero.  The purpose is to avoid changes
% of the reserved page space when we collect additional material from
% a page where an insertion of the appropriate kind had already been
% encountered.  This is used for filling up underfull pages.

\def\FN@recordinsertparam#1#2{\ifvoid#2\else
  \global\skip\number#2=\the\skip#2\relax\fi}

\def\FN@clearinsertparam#1#2{\ifvoid#2\else
  \global\skip#2=\z@skip\fi}

% \cmd{\FN@insertouterspace} will sum the size of the inserts manually.

\def\FN@insertouterspace#1#2{\ifvoid#2\else
    +\skip#2+(\ht#2+\dp#2)*\count#2/\@m\fi}

\def\FN@list@iterate#1{\let\FN@eltsave\@elt
  \let\@elt#1%
  \FN@list
  \let\@elt\FN@eltsave}

\def\FN@nest@iterate#1{\let\FN@eltsave\@elt
  \let\@elt#1%
  \FN@nestlist
  \let\@elt\FN@eltsave}

% This is our own output routine that does all the balancing stuff.
% If we receive a forced penalty here, we must not do any of our
% output processing on our own unless this is the choice of the
% underlying output routine.  We do want to have the `real' output
% routine to have a correct idea about the size that the insertions
% will take up.  So the steps that we \emph{will} actually perform in
% any case are sorting the insertions and calculating their real
% size.  If we have not had a forced penalty, we are free to exit the
% output routine for gathering further material as there are no
% expections of the underlying output routine when it should get
% called.  If we encountered a forced penalty, things are getting more
% complicated.  If the current page happens to be overfull after
% adding the current material, we first need to ship out the material
% for a regular page (after splitting off the necessary material for
% the next page).  We then reinsert the remaining split insertions,
% any possibly split off page material and the penalty.
% Unfortunately, this is not sufficient: the penalty might have been
% inserted with a box immediately preceding it.  In that case the
% penalty would have been guaranteed to eventually turn up in the
% output routine.  If we now reinsert merely all of the above stuff,
% the penalty will just disappear.  If we protect the penalty by
% placing an empty box before it when none of it had been before it
% before, we will get an empty page.  Since we don't know whether the
% penalty was supposed to disappear at the start of an empty page or
% not, we will do the following: if the rest of |\box255| is nonvoid,
% we just reinsert the split insertions followed by the rest of
% \box255 and the penalty and return.  If it is void, we call the
% regular output routine, capturing its output in a |\vbox| of its
% own.  If the regular output routine failed to ship out the prepared
% insertions, we just keep the original data either in their boxes or
% in a reinserted insertion.

% What we actually do for this reason is
% to do all the necessary calculations and store the result in the box
% |\FN@processedboxes|.  They will then be inserted

% It hides the relevant information from the `real' output routine
% until such a time that we have enough material gathered to produce a
% full page.  The exception to this is when we have a special penalty
% that gets passed through to the regular output routine.
%
% If we are on a material collecting spree, \cmd{\FN@savebox} contains
% all boxes from the last output call time.  At the point where we
% enter the output routine, \cmd{\FN@vsize} contains the amount of
% space available for mounting footnotes, after subtracting all
% insertions of footnote variety.  At most times in our output
% routine, the variable will contain the amount of space left after
% everything is put to the page including footnotes.

\savingvdiscards=\@ne

% We have the following situations that can cause us to enter the
% output routine:
% \begin{enumerate}
% \item The page has just filled up.
% \item A magic output penalty has been encountered.
% \item We are filling up a previously underfull page.
% \item We are looking for missing insertions that may have floated.
% \end{enumerate}
%
% In the situation where the page break has already been determined
% (magic output penalty, looking for missing insertions), we are not
% interested in `foreign' insertions like floating figures.  The
% current code does not cater for them.

\def\x#1{#1=\the#1}

\def\FN@lowestslave{0}

\output{%
%  \ifnum\c@page=10 \traceon\fi
  \ifvoid\FN@savebox
    \global\FN@outervsize\ht\@cclv\relax
    \global\setbox\@cclv\vbox{\unvbox\@cclv\boxmaxdepth\maxdepth}%
    \global\advance\FN@outervsize-\ht\@cclv\relax
  \else
    \dimen@\ht\@cclv
    \global\setbox\@cclv\vbox{\unvbox\@cclv\boxmaxdepth\maxdepth}%
    \global\advance\FN@outervsize\dimexpr\dimen@-\ht\@cclv\relax
% Now we invalidate the cache boxes for all insertions that had
% changed due to the recent additions to the page.
    \FN@nest@iterate\FN@maybeinvalidatecache
% We now update all boxes with the new data we collected    
    \vskip\z@skip
    \unvbox\FN@savebox
    \loop
      \count@\lastpenalty
    \ifnum\count@>\z@
      \unpenalty
      \setbox\z@\lastbox
      \global\setbox\count@\vbox{\unvbox\z@\unvbox\count@}%
    \repeat
    \count@\outputpenalty
    \FN@vsadjustlist
    \ifnum\count@=-13749
      \global\setbox\@cclv\lastbox
      \unskip
      \ifnum\outputpenalty<\@M \penalty\outputpenalty\fi
      \pagediscards
      \global\outputpenalty\@M
    \else
      \setbox\z@\lastbox
      \unskip
      \dimen@\dimexpr\ht\z@+\ht\@cclv
      \global\setbox\@cclv\vbox{\unvbox\z@
        \ifnum\outputpenalty<\@M \penalty\outputpenalty\fi
        \pagediscards\unvbox\@cclv
      \boxmaxdepth\maxdepth}%
      \global\outputpenalty\count@
      \global\advance\FN@outervsize\dimexpr\dimen@-\ht\@cclv
    \fi
    % Ok, now reset the relevant parameters to the stored values.
  \fi
  \gdef\FN@config{}%
  \FN@nest@iterate\FN@sortinsert
  \FN@nest@iterate\FN@regeneratecache
  \FN@nest@iterate{\FN@insertouterspace\global\FN@vsize\dimexpr\z@}
  \FN@nest@iterate{\FN@cachesize\skip@\glueexpr\z@skip}%
  \global\advance\FN@vsize\glueexpr\FN@outervsize-\skip@\relax
  \ifcase
    \ifnum\insertpenalties=\z@ \else \@ne\fi
    \ifdim\ht\@cclv>\z@ \else \@ne\fi
    \ifdim\FN@vsize<\glueshrink\FN@vsize \tw@ \fi
% page is overfull.  If there are no missing insertions, try to split.
% Else gather more material.
    \ifdim\FN@vsize>-\gluestretch\FN@vsize
      \ifdim\dimexpr\FN@vsize-\normalbaselineskip<\glueshrink\FN@vsize
      \else
% page is underfull, and the free space is at least that of a single
% line.  If we have no special output penalty, gather more material
        \ifnum\outputpenalty>-\@M \@ne\fi
      \fi
    \fi\z@
% page has appropriate size or we have special penalty.
    \gdef\FN@config{}%
    \count@\vbadness
    \vbadness\maxdimen
    \global\setbox\@cclv\vbox
      spread\FN@vsize{\unvbox\@cclv\boxmaxdepth\boxmaxdepth}%
    \vbadness\count@
    \the\FN@output
    \FN@nest@iterate\FN@clearcache
  \or
% we need additional material
    {\let\@elt\FN@recordinsertparam
     \xdef\FN@vsadjustlist{\global\vsize=\the\vsize
       \global\topskip=\the\topskip
       \global\outputpenalty=\the\outputpenalty\relax
       \FN@list}%
     \let\@elt\FN@clearinsertparam
     \FN@list}%
    \global\topskip-\maxdimen\relax
    \dimen@\ht\@cclv
    \global\setbox\FN@savebox\vbox{%
      \box\@cclv
      \FN@list@iterate\FN@sweepbox}%
    \ifdim\FN@vsize<\glueshrink\FN@vsize
      \ifdim\dimen@>\z@
        \hrule\@height\z@\@depth\z@
        \penalty -13749
        \global\vsize=0.5\maxdimen
      \else
        \global\vsize=3\normalbaselineskip
      \fi
    \else
      \global\vsize=\dimexpr\FN@vsize-\glueshrink\FN@vsize\relax
    \fi
    \global\advance\FN@outervsize-\vsize\relax
    \global\deadcycles\z@
  \else
% Fake our output box into something looking like a cache box
    \edef\FN@masterid{\number\maxdimen}%
    \def\FN@masterslot{-1}%
    \global\setbox\@cclv\vbox{%
      \box\@cclv}%
    \gdef\FN@config{}%
    \global\setbox\FN@savebox\vbox{}%
    \gdef\FN@badness{0}%
    \edef\FN@bestebadness{\number\maxdimen}%
    \edef\FN@defaultpenalty{\ifnum\outputpenalty<\@M
        \number\outputpenalty
      \else
        0\fi}%
    \let\@elt\FN@newlevel
    \@elt{}\FN@savebox\FN@nestlist\FN@mainsplitreturn
    \def\next{0}%
    \def\@elt#1#2{\ifnum\next<#1\relax
      \def\next{#1}%
      \fi}%
    \FN@config
    \ifnum\next>\z@
      \global\let\FN@lowestslave\next
    \fi
    \let\@elt\relax
    \global\setbox\FN@savebox\box\voidb@x
    \count@\vbadness
    \vbadness\maxdimen
    \global\setbox\@cclv\vbox spread\FN@vsize{%
      \unvbox\@cclv
      \ifnum\lastpenalty>\z@
        \unpenalty
        \global\setbox\FN@tempbox\lastbox
      \else
        \global\setbox\FN@tempbox\box\voidb@x
      \fi
      \MFL@removevboxes
      \boxmaxdepth\maxdepth}%
    \vbadness\count@
    \ifvoid\FN@tempbox\else
      \unvbox\FN@tempbox
      \ifnum\outputpenalty<\@M\penalty\outputpenalty\fi
    \fi
    \let\@elt\relax
    \the\FN@output
    \FN@nest@iterate\FN@clearcache
  \fi}
      

% Ok, here is the deal.  If the \cmd\FN@truevsize is negative, we have
% an overfull vbox at our hand.  We then start the splitting action.
% We take the first non-split lowest footnote block and split it to
% size, removing subordinate footnotes that we would not be able to
% maintain.  We do this recursively starting by the top footnote
% block.  It must be noted that it would be even better to start with
% the highest-numbered footnote (which corresponds to the latest
% finished footnote in \emph{logical} order, that in the source code),
% but then we get the problem that we might have to remove boxes from
% a footnote block that has already been split, and that is
% troublesome (to put it mildly) in case where the footnote block is
% set in paragraph mode.  It's bad enough backtracking in a fixed
% order across footnote blocks, going back and forward would be pretty
% tough.
%
% So our recursion just walks the footnote blocks once top to bottom,
% splitting and removing boxes that are not needed.  When we recurse,
% we have a dichotomy between current overfull and underfull boxes.
% At each recursion level, we enter with an overfull configuration
% that establishes the breakable section for the footnote block in
% question.  We then construct the footnote block and try splitting it
% to size.  If this
% gives us a \emph{good} underfull version, we return that (and break
% out of recursion altogether).  Otherwise we remember the underfull
% version before the break and recurse on the overfull version.  If
% this returns an overfull version again, we return the underfull
% version before the break.  If it returns an underfull version, we
% fill up the underfull version as much as possible without a change
% of configuration, then select the best of the last underfull and
% this as new local underfull.  We then take the first overfull
% combination (even allowing a change of configuration), throw away
% the previous split in the next recursion level and recurse on the
% now thoroughly overfull combination again.
%
% When recursion tops out, we compare the current overfull with the
% previous one and record the best.  We prefer keeping an older
% overfull, all other things being equal.
%
% Ok, so what are the data structures we maintain when going through
% all this folderol?
%
% We let the insertion boxes themselves remain untouched: that makes
% it only a bit more complicated to maintain and access the relevant
% boxes, but it might come handy at one time when somebody wants to
% implement recursion that is not strictly top-to-bottom.
%
% Instead we return the relevant information in the cache boxes.  The
% total size of the cache boxes may not correspond to their actual
% contents: in case a split box intended for the next page is stored
% within them, its height is deducted from the total height of the
% cache box (and, consequentially, from \cmd{\FN@vsize}).
%
% \cmd{\FN@vsize}, the amount of free space on the current page, is
% only updated when changing levels of recursion.  Instead we work
% with \cmd{\FN@myvsize} in our iterations here, which is set to the
% absolute maximum of material from this footnote admissable to the
% page.
%
% What about the penalties and badness we collect?  An unsplit
% footnote block carries a penalty of~0 (so we need not take into
% account unsplit footnote blocks at all during our bookkeeping, as
% they are neutral), a split footnote block is prepenalized with a
% penalty of~10000, plus the badness of the split, plus any penalties
% associated with the split (limited to the $[-10000\ldots10000]$
% range).  This means that no operation on other footnote blocks can
% lower an already accumulated score.  This in turn means that we can
% prune any operations leading to a worse score than the preceding
% best score without having to actually recurse.
%
% This strategy will usually buy us a minimum number of split
% footnotes (since the penalty of~10000 is not easy to compensate)
% and corresponds rather closely to \TeX's own idea of footnote
% splitting.

% The following routine will analyze a box where the results from
% \cmd{\splitdiscards} are stored and return the penalty associated
% with the breakpoint in the global macro \FN@breakpenalty.

\def\FN@getbreakpenalty#1{{\setbox\z@
    \vbox{\unvcopy#1%
      \count@\FN@defaultpenalty
      \FN@getbreakpenaltyii
      \xdef\FN@breakpenalty{\number\count@}%
    }}}

\def\FN@getbreakpenaltyii{%
  \ifcase
    \ifnum\lastnodetype<\z@ \m@ne\fi
    \ifnum\lastnodetype<11 \@ne\fi
    \ifnum\lastnodetype>13 \@ne\fi
    \numexpr\lastnodetype-9\relax
  \or
    \PackageError{bigfoot}{Illegal node type}{This can't happen}%
  \or
    \count@\z@ \unskip \expandafter\FN@getbreakpenaltyii
  \or
    \count@\z@ \unkern \expandafter\FN@getbreakpenaltyii
  \or
    \count@\lastpenalty
    \unpenalty \expandafter\FN@getbreakpenaltyii
  \fi}

\def\FN@mainsplitreturn{}

\newdimen\FN@myvsize
\newcount\bigfoottolerance
\bigfoottolerance=100

\def\FN@getbadness#1{%
  {\hfuzz\maxdimen\hbadness\maxdimen\setbox\z@\hbox to\z@{\hskip-#1}}}

\def\FN@newlevel#1#2#3\FN@mainsplitreturn{%
  \count@\csname FN@cache\number#2\endcsname
  \ifvoid\count@
%     \message{Page=\thepage #2 is empty, recursing with
%   \the\FN@vsize^^J}%
%     \message{Config=\FN@config^^J}%
      #3\FN@mainsplitreturn
%     \message{Page=\thepage #2 was empty, returning with \the\FN@vsize^^J}%
%     \message{Config=\FN@config^^J}%
  \else
    \iffoottrace\message{Entering #2 with \FN@badness}\fi
    {\def\FN@currentinsertion{#2}%
     \def\FN@currentrecursion{#3}%
     \let\FN@entryconfig\FN@config
     \let\FN@entrybadness\FN@badness
     \splittopskip\csname FN@ht\number#2\endcsname\relax
     \splitmaxdepth\csname FN@dp\number#2\endcsname\relax
     \vbadness=\maxdimen
     \vfuzz\maxdimen
     \let\@elt\relax
     \expandafter\FN@newleveli\expandafter}%
    \iffoottrace\message{Exiting #2 with \FN@badness}\fi
  \fi}

\def\FN@newleveli{%
% \cmd{\FN@vsize} already includes the size of the complete unsplit
% insertion.  When we recurse, it has to reflect the correct size at
% the time of recursion.  Rounding error problems don't permit us to
% accumulate any sizes in \cmd{\FN@vsize} from processing our current
% insertion, so we just subtract the whole insertion-related
% content.  We'll add stuff into it when recursing.
    \dimen@\dimexpr\ht\count@+\dp\count@\relax
    \global\advance\FN@vsize\dimexpr \dimen@
      *\count\FN@currentinsertion/\@m\relax\relax
% Ok, now we are typesetting and collecting the best box.  Notice
% that we \emph{don't} exit this \cmd{\setbox} command until we have
% found the best possible split.  What we \cmd{\unvbox} here, stays
% dormant except for the last box.  When we collect configurations
% from cache boxes, we don't collect anything from our current box
% that is being assembled.
    \global\setbox\count@\vbox\bgroup\unvbox\count@
      \edef\FN@bestconfig{\FN@entryconfig}%
      \edef\FN@bestvsize{-\the\maxdimen}%
      \setbox\tw@\box\voidb@x
      \setbox\z@\lastbox
% The last box may now be split.  First we note its main id.  Then we
% include its size into \cmd{\FN@vsize} as we have this much additional
% space available.
      \FN@myvsize=\dimexpr(\FN@vsize-\glueshrink\FN@vsize)%
        *\@m/\count\FN@currentinsertion-\dimen@+\ht\z@+\dp\z@\relax
% Ok, first attempt.  One interesting feature is that we will never
% have to rewind the boxes from a split: we can always just glue the
% box together again.  And apart from tentative splits which we might
% revert if they cause a configuration change, we will not have to
% bother about contributing too much.  What we put in the box here
% can stay.
%
% First we split to the remaining size.  After having done so, we
% continue splitting until we get the necessary mark of the last
% footnote into our grasp: we can't split before that.

      \ifnum\FN@currentinsertion=\FN@savebox
      \else
        \def\FN@defaultpenalty{-\@M}%
        \edef\FN@masterslot{\number\dp\z@}%
        \edef\FN@masterid{\FN@slotget\FN@masterslot}%
      \fi
      \nointerlineskip
      \vbox\bgroup
        \setbox4\box\voidb@x
        \ifnum\FN@currentinsertion=\FN@savebox
          \setbox\tw@\vsplit\z@ to\dimexpr\FN@myvsize-\splitmaxdepth\relax
        \else
          \loop
            \setbox\tw@\vsplit\z@ to\dimexpr\FN@myvsize-\splitmaxdepth\relax
          \ifnum0\splitbotmarks\FN@master=\FN@masterslot
          \else
            \FN@contribute@tw@
          \repeat
        \fi
% All of the above was necessary to ensure that we actually have the
% beginning of the relevant footnote in our material.  From now on,
% we are dealing with legal splits.
% Ok, now we have to check whether the subordinate configuration has
% changed.
        \edef\FN@slaveid{\splitbotmarks\FN@slave}%
        \ifx\FN@slaveid\@empty
          \let\FN@slaveid\FN@lowestslave%
        \fi
        \FN@contribute@tw@
        \ifnum\numexpr\FN@slaveid+\@ne<\FN@masterid
          \let\FN@next\FN@slaveid
        \else
          \let\FN@next\@empty
        \fi
% At this point of time, we have \cmd{\FN@masterid} set properly for
% our purposes.  \cmd{\FN@slaveid} is by necessity not empty.  If any
% footnote has had its mark broken off, its id must be in the open
% range between \cmd{\FN@slaveid} and \cmd{\FN@masterid}.  So a
% nonempty value of \cmd{\FN@next} at this point of time indicates
% that we have to cater for a different configuration rather than the
% currently cached one.
        \FN@splitfurther}

% Main label for reconsideration
% We are after a split to size without configuration change, or a
% split that caused a configuration change and was reverted for a slow
% motion split.  So whatever we do now up to the next configuration
% change will happen in slow motion.

\def\FN@splitfurther{%
  \ifx\FN@next\@empty
  \else
% Ok, we had a compulsory change in configuration.  Reconfigure.
    \let\FN@slaveid\FN@next
    \FN@myvsize\dimexpr\FN@myvsize-%
      (\FN@vsize-\glueshrink\FN@vsize)*\@m/\count\FN@currentinsertion\relax
    \xdef\FN@config{%
      \@elt{\FN@slaveid}%
        {\FN@masterid}%
      \FN@entryconfig}%
    \let\@elt\FN@reconfig
    \FN@currentrecursion
    \let\@elt\relax
    \FN@myvsize\dimexpr\FN@myvsize+%
      (\FN@vsize-\glueshrink\FN@vsize)*\@m/\count\FN@currentinsertion\relax
  \fi
  \FN@getbreakpenalty4%
  \xdef\FN@badness{\number\numexpr\FN@entrybadness+\@M+\FN@breakpenalty}%
  \let\FN@next\FN@breakpenalty
% No point in recursing if we can't beat the current best one.
  \ifnum\FN@badness<\FN@bestebadness
%          are we overfull?  If so, recurse once for getting better.
    \ifdim\FN@myvsize<\z@
      \advance\FN@myvsize-\dimexpr
        (\FN@vsize-\glueshrink\FN@vsize)%
         *\@m/\count\FN@currentinsertion\relax
      \global\advance\FN@vsize\dimexpr\FN@myvsize
        *\count\FN@currentinsertion/\@m\relax\relax
      \let\@elt\FN@newlevel
      \FN@currentrecursion\FN@mainsplitreturn
      \let\@elt\relax
      \global\advance\FN@vsize-\dimexpr\FN@myvsize
        *\count\FN@currentinsertion/\@m\relax\relax
      \advance\FN@myvsize\dimexpr
        (\FN@vsize-\glueshrink\FN@vsize)%
        *\@m/\count\FN@currentinsertion\relax
    \fi
  \fi
  \global\let\FN@breakpenalty\FN@next
  \xdef\FN@badness{\number\numexpr\FN@badness-\FN@breakpenalty}%
% At this point of time, everything to get an overfull box averted has
% been attempted already.  Any material that would be taken over from
% the next page will add at least a full line height to what we have
% already, so we don't bother unless we have room for that.
  \ifdim\FN@myvsize<\dimexpr\splitmaxdepth+\splittopskip\relax
    \skip@\glueexpr\FN@vsize+(\dimexpr\FN@myvsize
      -(\FN@vsize-\glueshrink\FN@vsize)%
       *\@m/\count\FN@currentinsertion)%
     *\count\FN@currentinsertion/\@m\relax
    \FN@getbadness\skip@
    \expandafter\FN@returnbest
  \else
    \expandafter\FN@addmaterial
  \fi}

\def\FN@returnbest{%
  \skip@\FN@bestvsize\relax
  \dimen@\dimexpr\FN@vsize+(\dimexpr\FN@myvsize
      -(\FN@vsize-\glueshrink\FN@vsize)%
       *\@m/\count\FN@currentinsertion)%
     *\count\FN@currentinsertion/\@m\relax
  \ifnum\badness>\@M
% Overfull boxes are considered terrible.
    \def\FN@ebadness{\number\numexpr\maxdimen-\@ne}%
  \else
    \ifnum\badness=\@M
      \edef\FN@ebadness{\number\numexpr\maxdimen-\tw@}%
    \else
      \edef\FN@ebadness{\number\numexpr\FN@badness+\FN@breakpenalty+\badness}%
    \fi
  \fi
  \ifcase
    \ifnum\FN@bestebadness<\FN@ebadness \@ne\fi
    \ifnum\FN@bestebadness>\FN@ebadness \tw@\fi
    \ifdim\dimen@<\z@
% Among the overfull boxes, the least overfull is king.
      \ifdim\skip@>\dimen@ \@ne \fi \tw@
    \fi
% Among the equally bad underfull boxes, prefer the fuller one.
    \ifdim\skip@<\dimen@ \@ne \fi \tw@
  \or
% We have an earlier contender.
    \global\let\FN@config\FN@bestconfig
    \global\FN@vsize\FN@bestvsize
    \global\let\FN@badness\FN@bestbadness
    \egroup
% Remove the currently typeset box from the list.
    \setbox\z@\lastbox
% Restore the saved configuration.
    \nointerlineskip
    \vbox{%
      \unvbox\tw@
      \loop
        \count@\lastpenalty
      \ifnum\count@>\z@
        \unpenalty
        \global\setbox\count@\lastbox
      \repeat
      \unkern
% Move the split-off box intended to be carried to the next page into
% box~\cmd{\FN@tempbox}.
      \global\setbox\FN@tempbox\lastbox
      \setbox\z@\lastbox
      \ifvoid\z@
        \unvbox\FN@tempbox
      \else
        \unvbox\z@
        \ifx\FN@bestsplitcolors\@empty\else
          \dimen@\dp\FN@tempbox
          \global\setbox\FN@tempbox\vbox{%
            \FN@coloraftersplit\FN@bestsplitcolors
            \nointerlineskip\nobreak
            \unvbox\FN@tempbox}%
          \ht\FN@tempbox
            \dimexpr\ht\FN@tempbox+\dp\FN@tempbox-\dimen@\relax
          \dp\FN@tempbox\dimen@
      \fi\fi}%
  \else
    \xdef\FN@badness{\number\numexpr\FN@badness+\FN@breakpenalty}%
    \global\advance\FN@vsize\dimexpr(\FN@myvsize
      -(\FN@vsize-\glueshrink\FN@vsize)%
       *\@m/\count\FN@currentinsertion)%
     *\count\FN@currentinsertion/\@m\relax\relax
% Now box~0 is the box we need to carry to the next page.  Prepare
% the box into box~\cmd{\FN@tempbox}.
    \ifnum\FN@currentinsertion=\FN@savebox
    \else
      \ifvoid\z@\else
        \setbox\z@\vbox{\marks\FN@master{\FN@masterslot}%
          \marks\FN@slave{\FN@slaveid}%
          \FN@coloraftersplit\FN@splitcolors
          \nobreak
          \unvbox\z@}%
        \wd\z@\maxdimen
        \ht\z@\dimexpr\ht\z@+\dp\z@-\FN@masterslot sp\relax
        \dp\z@ \FN@masterslot sp\relax
      \fi
    \fi
    \global\setbox\FN@tempbox\box\z@
    \egroup
  \fi
% If nothing is to be carried over, we just finish our assignment to
% the cache box and return.
  \ifvoid\FN@tempbox \egroup
% If not, we add the carried-over box to the list, flag it with a
% \cmd{\nobreak}, and subtract its size from the finished box.
  \else
    \FN@carriedegroup\FN@tempbox
  \fi
}

\def\FN@carriedegroup#1{\dimen@-\dimexpr\ht#1+\dp#1\relax
  \nointerlineskip\box#1%
  \nobreak
  \expandafter\egroup
  \expandafter\ht\expandafter\count@\expandafter\dimexpr
  \the\dimen@+\ht\count@\relax}

\def\FN@addmaterial{%
  \setbox\tw@\vsplit\z@ to\dimexpr\FN@myvsize-\splitmaxdepth\relax
  \ifcase\ifvoid\tw@ \@ne\fi
  \ifnum\badness>\@M \@ne\fi\z@
    \edef\FN@next{\splitbotmarks\FN@slave}%
    \ifx\FN@next\@empty
% The split was successful and yields a new best underfull in our
% current configuration.
      \FN@contribute@tw@
      \expandafter\expandafter\expandafter
      \FN@recordbest
    \else
% the split would result in a configuration change, so undo it and
% revert to slow motion
      \FN@uncontribute@tw@
      \expandafter\expandafter\expandafter
      \FN@slowsplit
     \fi
  \else
% Oops, looks like there is nothing at all that we could contribute
% without getting overfull.  So the unsplit version is the best we can
% manage with this configuration.
    \FN@uncontribute@tw@
    \expandafter\FN@recordbest
  \fi}

\def\FN@slowsplit{\setbox\tw@\vsplit\z@ to\z@
  \edef\FN@next{\splitbotmarks\FN@slave}%
  \ifx\FN@next\@empty \FN@contribute@tw@
    \expandafter\FN@slowsplit
  \else
    \iffoottrace
      \message{Slowsplit in \FN@currentinsertion on \thepage^^J}%
    \fi
    \FN@uncontribute@tw@
    \expandafter
    \FN@recordbest
  \fi}

\def\FN@recordbest{%
  \skip@\glueexpr\FN@vsize+(\dimexpr\FN@myvsize
    -(\FN@vsize-\glueshrink\FN@vsize)%
     *\@m/\count\FN@currentinsertion)%
   *\count\FN@currentinsertion/\@m\relax
  \FN@getbreakpenalty4%
  \FN@getbadness\skip@
  \ifnum\badness>\@M
    \edef\FN@ebadness{\number\numexpr\maxdimen-\@ne}%
  \else
    \ifnum\badness=\@M
      \edef\FN@ebadness{\number\numexpr\maxdimen-\tw@}%
    \else
      \edef\FN@ebadness{\number\numexpr
        \FN@badness+\FN@breakpenalty+\badness}%
    \fi
  \fi
  \dimen@\glueexpr\FN@bestvsize\relax
% If the current break is satisfactory, we can just return it.
  \ifcase
    \ifnum\FN@ebadness>\bigfoottolerance
      \else \@ne\fi
% If no change of configuration follows later, we can return the best
% up to now.
    \ifnum\numexpr\FN@slaveid+\@ne<\numexpr\FN@masterid\relax
      \else \@ne\fi
    \ifvoid\z@ \@ne\fi \z@
% Ok, so the split was not as good as to cause us to return
% immediately, and it also was not the last opportunity for a split
% (which again would make us return immediately).
% So we check if it is at least better than the last one, in which
% case we need to replace the previous best.
    \ifcase
      \ifnum\FN@bestebadness>\FN@ebadness \@ne\fi
      \ifnum\FN@bestebadness<\FN@ebadness \tw@\fi
      \ifdim\skip@<\z@
        \ifdim\dimen@<\skip@ \@ne \else \tw@\fi
      \fi
      \ifdim\dimen@>\skip@ \@ne\fi \tw@
    \or
      \xdef\FN@tempinfo{\def\noexpand\FN@bestvsize{\the\skip@}%
        \def\noexpand\FN@bestebadness{\FN@ebadness}%
        \def\noexpand\FN@bestbadness{\number\numexpr\FN@badness+%
          \FN@breakpenalty}%
        \def\noexpand\FN@bestconfig{\FN@config}%
        \def\noexpand\FN@slaveid{\FN@slaveid}%
        \def\noexpand\FN@bestsplitcolors{\FN@splitcolors}%
        \FN@myvsize=\the\FN@myvsize\relax}%
      \global\setbox\FN@tempbox\vbox{\box4\nointerlineskip\box\z@}%
      \egroup
      \FN@tempinfo
      \setbox\z@\lastbox
%Now all relevant info has been retrieved, and we collect the best
%box info in box two.  We start with the current list.  Disassembling
%\cmd{\FN@tempbox} first has the advantage that the case of box~4
%being void does not need extra treatment.
      \setbox\tw@\vbox{\unvcopy\FN@tempbox
        \setbox\tw@\lastbox \setbox4\lastbox
        \nointerlineskip\copy\z@
        \ifnum\FN@currentinsertion=\FN@savebox
          \setbox\z@\box\tw@
        \else
          \setbox\z@\vbox{\marks\FN@master{\FN@masterslot}%
            \marks\FN@slave{\FN@slaveid}%
            \nobreak
            \unvbox\tw@}%
          \wd\z@\maxdimen
          \ht\z@\dimexpr\ht\z@+\dp\z@-\FN@masterslot sp\relax
          \dp\z@ \FN@masterslot sp\relax
        \fi
        \nointerlineskip \box\z@
        \kern\z@
        \let\@elt\FN@cachesize
        \advance\FN@myvsize-\dimexpr
          (\FN@vsize-\glueshrink\FN@vsize)%
           *\@m/\count\FN@currentinsertion\relax
        \global\advance\FN@vsize\glueexpr\z@skip\FN@currentrecursion\relax
        \let\@elt\FN@sweepcachebox
        \FN@currentrecursion
        \advance\FN@myvsize\dimexpr
          (\FN@vsize-\glueshrink\FN@vsize)%
          *\@m/\count\FN@currentinsertion\relax
        \xdef\FN@tempinfo{\FN@myvsize=\the\FN@myvsize\relax}}%
      \FN@tempinfo
      \nointerlineskip
      \vbox\bgroup\unvbox\FN@tempbox \setbox\tw@\lastbox
        \setbox4\lastbox \unvbox\z@
        \setbox\z@\box\tw@
    \fi
    \loop
      \setbox\tw@\vsplit\z@ to\z@
      \edef\FN@next{\splitbotmarks\FN@slave}%
      \FN@contribute@tw@
      \ifcase
        \ifvoid\z@\@ne\fi
        \ifx\FN@next\@empty\else\@ne\fi\z@
    \repeat
    \expandafter\FN@splitfurther
  \or
    \expandafter\FN@returnbest
  \fi}

% \cmd{\FN@contribute@tw@} will go from the state where we have the
% previous \cmd{\splitdiscards} in box~4 and some material split off
% from box~0 in box~2 to a state where box~2 is contributed to the
% current list, if necessary extended by a strut to achieve the
% maximal depth.

\def\FN@contribute@tw@{%
% we want to contribute box~2 back without any topskip glue, so we
% manually remove any such glue by splitting an empty box off.
  \edef\FN@splitcolors{\splitbotmarks\FN@color}%
  \ifvoid4
    \setbox4\vbox{\splitdiscards}%
    \setbox\tw@\vbox{\unvbox\tw@}%
  \else
    \advance\FN@myvsize-\ht4\relax
    \unvbox4
    \setbox4\vbox{\splitdiscards}%
    \setbox\tw@\vbox{\break\unvbox\tw@}%
    {\splittopskip-\maxdimen \setbox\tw@\vsplit\tw@ to\z@}%
  \fi
% Notice the effect of \TeX's special box scope rules: box~2 assigned
% just right now will be affected by the split.  The result of the
% split will be an empty box that will temporarily overwrite box~2
% within the group, but will be restored back to the split result on
% exit.  In this manner, any topskip glue will have disappeared.
% After the split, box~2 is set to the natural depth and height of
% its contents.
  \advance\FN@myvsize-\dimexpr\ht\tw@+\dp\tw@\relax
  \dimen@\dp\tw@
  \unvbox\tw@
% If this depth does not reach \splitmaxdepth, we add a strut that
% will cause the depth to be reached exactly.  We have to remove the
% added distance from the contents of box~4 in case that this split
% will not be permanent and a need would arise to glue the stuff back
% together with following stuff from box~0.
  \ifdim\dimen@<\splitmaxdepth
    \hrule\@height-\dimen@\@width\z@\@depth\splitmaxdepth
    \advance\dimen@-\splitmaxdepth
    \setbox4\vbox{\unvbox4\vskip\dimen@}%
    \advance\FN@myvsize\dimen@
  \fi}

\def\FN@uncontribute@tw@{%
  \ifvoid\tw@ \else
  \setbox\tw@\vbox{\unvbox\tw@\splitdiscards}%
  \setbox\z@\vbox{\break\unvbox\z@}%
  {\splittopskip-\maxdimen \setbox\z@\vsplit\z@ to\z@}%
  \setbox\z@\vbox{\unvbox\tw@\unvbox\z@}\fi}

\def\FN@reconfig#1#2{\ifvoid#2\else
  \count@\csname FN@cache\number#2\endcsname
  \ifvoid\count@\else
    \global\advance\FN@vsize
      \glueexpr(\ht\count@+\dp\count@)*\count#2/\@m+\skip#2\relax
    \global\setbox\count@ \box\voidb@x
  \fi
  \global\setbox\count@\vbox\bgroup\unvcopy#2%
    \let\@elt\FN@removecheck
    \FN@retainkept
    \ifvoid\z@ \egroup \global\setbox\count@ \box\voidb@x
    \else \def\FN@masterinsert{#2}%
    \FN@assembleboxes\nointerlineskip\box\z@
    \egroup \global\advance\FN@vsize
      -\glueexpr(\ht\count@+\dp\count@)*\count#2/\@m+\skip#2\relax
  \fi\fi}

\let\output\FN@output
